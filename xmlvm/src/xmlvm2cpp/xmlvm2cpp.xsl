<?xml version="1.0"?>


<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xs = "http://www.w3.org/2001/XMLSchema"
                xmlns:vm ="http://xmlvm.org"
                xmlns:jvm="http://xmlvm.org/jvm"
                xmlns:dex="http://xmlvm.org/dex"
                version="2.0">

<xsl:param name="pass">emitHeader</xsl:param>
<xsl:param name="header">xmlvm.h</xsl:param>

<xsl:output method="text" indent="no"/>

<xsl:template match="vm:xmlvm">
  <xsl:text>
// Automatically generated by xmlvm2cpp.xsl. Do not edit!

</xsl:text>  




  <xsl:choose>
    <xsl:when test="$pass = 'emitHeader'">
      <xsl:text>
	</xsl:text>
      <xsl:call-template name="emitInterfaces"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>
#import "</xsl:text>
      <xsl:value-of select="$header"/>
      <xsl:text>"

</xsl:text>
      <xsl:call-template name="emitImplementation"/>
      
      <xsl:if test="vm:class/vm:method/@name = 'main'">
        <xsl:call-template name="emitMainMethod"/>
      </xsl:if>
      
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>



<xsl:template name="emitMainMethod">
  <xsl:text>
  
      
int main(int argc, char* argv[])
{
	xmlvm_init();
    </xsl:text>
    <xsl:variable name="cl" as="node()" select="vm:class/vm:method[@name = 'main']/.."/>
    <xsl:value-of select="vm:fixname($cl/@package)"/>
    <xsl:text>_</xsl:text>
    <xsl:value-of select="$cl/@name"/>
    <xsl:text>::main___java_lang_String_ARRAYTYPE((XMLVMArray*) JAVA_NULL);
    return 0;
}
  
  
</xsl:text>
</xsl:template>



<xsl:template name="emitInterfaces">
  <xsl:for-each select="vm:class">
    <xsl:variable name="cclname" select="concat(@package, '.', @name)"/>
    <xsl:variable name="clname" select="vm:fixname($cclname)"/>
  
    <xsl:text>
</xsl:text>
    <xsl:text>class </xsl:text>
    <xsl:value-of select="vm:fixname(@package)"/>
    <xsl:text>_</xsl:text>
    <xsl:value-of select="vm:fixname(@name)"/>
    <xsl:if test="not(@isInterface = 'true')">
      <xsl:text> :</xsl:text>
      <xsl:if test="@interfaces">
        <xsl:text> virtual</xsl:text>
      </xsl:if>
      <xsl:text> public </xsl:text>
      <xsl:value-of select="if (@extends='') then 'XMLVMRootObject' else vm:fixname(@extends)"/>
    </xsl:if>

    <xsl:if test="@interfaces">
      <!-- Only use virtual inheritance if we inherit from more than one C++ class. -->
      <!-- The number of C++ classes is the sum of the base class plus all interfaces. -->
      <xsl:variable name="needsVirtualInheritance" select="(@isInterface = 'true' and contains(@interfaces, ',')) or
                                                           not(@isInterface = 'true')"/>
      <xsl:value-of select="if (@isInterface = 'true') then ':' else ','"/>
      <xsl:choose>
        <xsl:when test="$needsVirtualInheritance">
          <xsl:text> virtual public </xsl:text>
          <xsl:value-of select="vm:fixname(replace(@interfaces, ',', ', virtual public '))"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text> public </xsl:text>
          <xsl:value-of select="vm:fixname(replace(@interfaces, ',', ', public '))"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
      <xsl:text> {
public:
</xsl:text>
    <xsl:if test="not(@isInterface = 'true')">
      <xsl:text>
static int __class_initialized;
static void __init_class();
</xsl:text>
      <!-- Emit default constructor -->
      <xsl:value-of select="vm:fixname(@package)"/>
      <xsl:text>_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>();
</xsl:text>

      <!-- Emit destructor -->
      <xsl:text>virtual ~</xsl:text>
      <xsl:value-of select="vm:fixname(@package)"/>
      <xsl:text>_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>();
</xsl:text>

      <!-- Emit declarations for all non-static fields -->
      <xsl:for-each select="vm:field[not(@isStatic = 'true')]">
        <xsl:call-template name="emitType">
          <xsl:with-param name="type" select="@type"/>
        </xsl:call-template>
        <xsl:text> </xsl:text>
        <xsl:value-of select="vm:fixname(@name)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(@type)"/>
        <xsl:text>;
</xsl:text>
      </xsl:for-each>
    </xsl:if>
    <!-- Emit declarations for getter and setter methods for all static fields -->
    <xsl:for-each select="vm:field[@isStatic = 'true']">
      <!-- Emit getter -->
      <xsl:text>static </xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text> _GET_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>();
</xsl:text>
      <!-- Emit setter -->
      <xsl:text>static void _PUT_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>(</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text> v)</xsl:text>
      <xsl:text>;
</xsl:text>
      <!-- Emit releaser -->
      <xsl:if test="vm:isObjectRef(@type)">
        <xsl:text>static void _RELEASE_</xsl:text>
        <xsl:value-of select="vm:fixname(@name)"/>
        <xsl:text>();
</xsl:text>
      </xsl:if>
      
    </xsl:for-each>
    <!-- Emit declarations for all methods -->
    <xsl:for-each select="vm:method">
      <xsl:if test="not(vm:isDuplicateMethod(.))">
        <xsl:call-template name="emitMethodSignature">
          <xsl:with-param name="forDeclaration" select="1"/>
        </xsl:call-template>
        <xsl:text>;
</xsl:text>
      </xsl:if>
    </xsl:for-each>
      
    <xsl:text>
};

</xsl:text>
  </xsl:for-each>
  
</xsl:template>


<xsl:template name="emitImplementation">
  <xsl:for-each select="vm:class[not(@isInterface = 'true')]">
  
    <xsl:variable name="clname">
        <xsl:value-of select="vm:fixname(@package)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(@name)"/>
    </xsl:variable>

    <xsl:text>int </xsl:text>
    <xsl:value-of select="$clname"/>
    <xsl:text>::__class_initialized = 0;

</xsl:text>

    <!-- Emit global variable definition for all static fields -->
    <xsl:for-each select="vm:field[@isStatic = 'true']">
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text> _STATIC_</xsl:text>
      <xsl:value-of select="$clname"/>
      <xsl:text>_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:if test="@value">
        <xsl:text> = </xsl:text>
        <!-- TODO String values need to be surrounded by quotes and escaped properly. -->
        <xsl:if test="@type = 'java.lang.String'">
          <xsl:text>new java_lang_String("</xsl:text>
        </xsl:if>
        <xsl:value-of select="@value"/>
        <xsl:if test="@type = 'java.lang.String'">
          <xsl:text>")</xsl:text>
        </xsl:if>
      </xsl:if>
      <xsl:text>;
</xsl:text>
    </xsl:for-each>

    <!-- Emit class initializers -->
    <xsl:text>void </xsl:text>
    <xsl:value-of select="$clname"/>
    <xsl:text>::__init_class()
{
    __class_initialized = 1;
</xsl:text>
        <xsl:for-each select="vm:field[@isStatic = 'true' and vm:isObjectRef(@type)]">
          <xsl:text>
    _STATIC_</xsl:text>
          <xsl:value-of select="vm:fixname(../@package)"/>
          <xsl:text>_</xsl:text>
          <xsl:value-of select="vm:fixname(../@name)"/>
          <xsl:text>_</xsl:text>
          <xsl:value-of select="vm:fixname(@name)"/>
          <xsl:text> = (</xsl:text>
          <xsl:value-of select="vm:fixname(@type)"/>
          <xsl:text>*) JAVA_NULL;</xsl:text>
        </xsl:for-each>
    	<!-- If there is a Java class initializer, call it. -->
        <xsl:if test="vm:method[@name = '&lt;clinit&gt;']">
          <xsl:text>
    </xsl:text>
          <xsl:value-of select="vm:fixname(@package)"/>
          <xsl:text>_</xsl:text>
          <xsl:value-of select="vm:fixname(@name)"/>
          <xsl:text>::__clinit_</xsl:text>
          <xsl:value-of select="vm:fixname(@package)"/>
          <xsl:text>_</xsl:text>
          <xsl:value-of select="vm:fixname(@name)"/>
          <xsl:text>();</xsl:text>
        </xsl:if>
    <xsl:text>
}

</xsl:text>
    
    <!-- Emit default constructor for member initialization -->
    <xsl:value-of select="$clname"/>
    <xsl:text>::</xsl:text>
    <xsl:value-of select="$clname"/>
    <xsl:text>()
{
    if (!__class_initialized) __init_class();
</xsl:text>
      <!-- Emit declarations for all non-static member fields -->
    <xsl:for-each select="vm:field[not(@isStatic = 'true') and vm:isObjectRef(@type)]">
      <xsl:text>        </xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>_</xsl:text>
      <xsl:value-of select="vm:fixname(@type)"/>
      <xsl:text> = </xsl:text>
      <xsl:text>(</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text>) </xsl:text>
      <xsl:text>JAVA_NULL;
      </xsl:text>
    </xsl:for-each>
    <xsl:text>
}

</xsl:text>

    <!-- Emit destructor -->
    <xsl:value-of select="$clname"/>
    <xsl:text>::~</xsl:text>
    <xsl:value-of select="$clname"/>
    <xsl:text>()
{
</xsl:text>
    <xsl:if test="vm:method[@name='finalize' and 
                        not(vm:signature/vm:parameter) and 
                        vm:signature/vm:return[@type='void']]">
      <xsl:text>    this->finalize_</xsl:text><xsl:value-of select="vm:fixname(concat(@package, '.', @name))"/><xsl:text>__();
</xsl:text>
    </xsl:if>
	<xsl:for-each select="vm:field[not(@isStatic = 'true') and vm:isObjectRef(@type) and
	                      not(@isSynthetic = 'true' and starts-with(@name, 'this$'))]">
	  <xsl:text>    </xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>_</xsl:text>
      <xsl:value-of select="vm:fixname(@type)"/>
	  <xsl:text>->__release();
</xsl:text>
	</xsl:for-each>
	<xsl:text>}
</xsl:text>

	<!-- Emit getters and setters for all static fields -->
    <xsl:for-each select="vm:field[@isStatic = 'true']">
      <!-- Emit getter -->
      <xsl:variable name="field">
        <xsl:value-of select="vm:fixname(../@package)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(../@name)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(@name)"/>
      </xsl:variable>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text> </xsl:text>
      <xsl:value-of select="$clname"/>
      <xsl:text>::_GET_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>()
{
    if (!__class_initialized) __init_class();
    return </xsl:text>
      <xsl:text>_STATIC_</xsl:text>
      <xsl:value-of select="$field"/>
      <xsl:text>;
}

</xsl:text>
      <!-- Emit setter -->
      <xsl:text>void </xsl:text>
      <xsl:value-of select="$clname"/>
      <xsl:text>::_PUT_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>(</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text> v)
{
    if (!__class_initialized) __init_class();
    </xsl:text>
      <xsl:text>_STATIC_</xsl:text>
      <xsl:value-of select="$field"/>
      <xsl:text> = v;
}

</xsl:text>

      <!-- Emit releaser -->
<xsl:if test="vm:isObjectRef(@type)">
      <xsl:text>void </xsl:text>
      <xsl:value-of select="$clname"/>
      <xsl:text>::_RELEASE_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>()
{
    </xsl:text>
      <xsl:text>_STATIC_</xsl:text>
      <xsl:value-of select="$field"/>
      <xsl:text>-&gt;__release();
}

</xsl:text>
</xsl:if>
    </xsl:for-each>
    
    <xsl:for-each select="vm:method">
      <xsl:if test="not(vm:isDuplicateMethod(.)) and not(../.[@isInterface = 'true'] or @isAbstract = 'true')">
        <xsl:call-template name="emitMethodSignature">
          <xsl:with-param name="forDeclaration" select="0"/>
        </xsl:call-template>
        <xsl:text>
</xsl:text>
        <xsl:choose>
          <xsl:when test="@isNative = 'true'">
            <xsl:text>{
    ERROR("Native method not implemented");
}

</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:apply-templates/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
    </xsl:for-each>
  </xsl:for-each>
  
</xsl:template>


<xsl:template match="vm:signature">
  <!-- Do nothing -->
</xsl:template>


<xsl:template match="jvm:var">
  <!-- Do nothing -->
</xsl:template>


<xsl:template match="jvm:label">
  <xsl:text>    label</xsl:text>
  <xsl:value-of select="@id"/>
  <xsl:text>:;
</xsl:text>
</xsl:template>



<xsl:template name="emitType">
  <xsl:param name="type"/>
  <xsl:choose>
    <xsl:when test="$type = 'void'">
      <xsl:text>void</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'char'">
      <xsl:text>JAVA_CHAR</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'byte'">
      <xsl:text>JAVA_BYTE</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'short'">
      <xsl:text>JAVA_SHORT</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'int'">
      <xsl:text>JAVA_INT</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'long'">
      <xsl:text>JAVA_LONG</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'float'">
      <xsl:text>JAVA_FLOAT</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'double'">
      <xsl:text>JAVA_DOUBLE</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'boolean'">
      <xsl:text>JAVA_BOOLEAN</xsl:text>
    </xsl:when>
    <xsl:when test="ends-with($type, '[]')">
      <xsl:text>XMLVMArray*</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="vm:fixname($type)"/>
      <xsl:text>*</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<xsl:template name="emitMethodName">
  <xsl:param name="name"/>
  <xsl:param name="class-type"/>
  <xsl:choose>
    <xsl:when test="$name = '&lt;init&gt;'">
      <xsl:text>__init_</xsl:text>
      <xsl:value-of select="vm:fixname($class-type)"/>
    </xsl:when>
    <xsl:when test="$name = '&lt;clinit&gt;'">
      <xsl:text>__clinit_</xsl:text>
      <xsl:value-of select="vm:fixname($class-type)"/>
    </xsl:when>
    <xsl:when test="$name = 'finalize'">
      <xsl:text>finalize_</xsl:text>
      <xsl:value-of select="vm:fixname($class-type)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$name"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<xsl:template name="emitMethodSignature">
  <xsl:param name="forDeclaration"/>
  <xsl:if test="$forDeclaration = 1">
    <xsl:value-of select="if (@isStatic = 'true') then 'static' else 'virtual'"/>
    <xsl:text> </xsl:text>
  </xsl:if>
  <xsl:call-template name="emitType">
    <xsl:with-param name="type" select="vm:signature/vm:return/@type"/>
  </xsl:call-template>
  <xsl:text> </xsl:text>
  <xsl:if test="$forDeclaration = 0">
    <xsl:value-of select="vm:fixname(concat(../@package, '.', ../@name))"/>
    <xsl:text>::</xsl:text>
  </xsl:if>
  <xsl:call-template name="emitMethodName">
    <xsl:with-param name="name" select="@name"/>
    <xsl:with-param name="class-type" select="concat(../@package, '.', ../@name)"/>
  </xsl:call-template>
  <xsl:if test="@name != '&lt;clinit&gt;'">
    <xsl:call-template name="appendSignature"/>
    <xsl:text>(</xsl:text>
    <xsl:for-each select="vm:signature/vm:parameter">
      <xsl:if test="position() != 1">
        <xsl:text>, </xsl:text>
      </xsl:if>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text> n</xsl:text>
      <xsl:value-of select="position()"/>
    </xsl:for-each>
    <xsl:text>)</xsl:text>
    <xsl:if test="(../@isInterface = 'true' and $forDeclaration = 1) or @isAbstract = 'true'">
      <xsl:text> = 0</xsl:text>
    </xsl:if>
  </xsl:if>
  <xsl:if test="@name = '&lt;clinit&gt;'">
    <xsl:text>()</xsl:text>
  </xsl:if>
</xsl:template>


<xsl:template name="appendSignature">
  <xsl:text>__</xsl:text>
  <xsl:choose>
    <xsl:when test="count(vm:signature/vm:parameter) != 0">
      <xsl:for-each select="vm:signature/vm:parameter">
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(@type)"/>
      </xsl:for-each>
    </xsl:when>
  </xsl:choose>
</xsl:template>

    
<xsl:template name="emitTypedAccess">
  <xsl:param name="type"/>
  
  <xsl:text>.</xsl:text>
  <xsl:choose>
    <xsl:when test="$type = 'boolean' or $type = 'byte' or $type = 'char' or $type = 'short' or $type = 'int'">
      <xsl:text>i</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'float'">
      <xsl:text>f</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'double'">
      <xsl:text>d</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'long'">
      <xsl:text>l</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>o</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<xsl:template name="emitTypedArrayAccess">
  <xsl:param name="type"/>
  
  <xsl:text>.</xsl:text>
  <xsl:choose>
    <xsl:when test="$type = 'boolean[]' or $type = 'byte[]'">
      <xsl:text>b</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'char[]'">
      <xsl:text>c</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'short[]'">
      <xsl:text>s</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'int[]'">
      <xsl:text>i</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'float[]'">
      <xsl:text>f</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'double[]'">
      <xsl:text>d</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'long[]'">
      <xsl:text>l</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>o</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!--  javac will sometimes generate two methods that only differ in their return type.
      This can happen e.g. with type erasures. Function vm:isDuplicateMethod will determine
      if the given method is a duplicate that is not needed when generating Objective-C (in fact,
      Objective-C does not permit two methods that only differ in their return type).
      A method is a duplicate if it is (1) synthetic, (2) a method with the same name exists
      in the class, and (3) signatures only differ in their return types.  -->
<xsl:function name="vm:isDuplicateMethod" as="xs:boolean">
  <xsl:param name="method" as="node()"/>

  <xsl:choose>
    <xsl:when test="not($method/@isSynthetic = 'true')">
      <xsl:value-of select="false()"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="name" select="$method/@name"/>
      <xsl:variable name="methodsWithSameName" select="$method/../vm:method[@name = $name]"/>
      <xsl:variable name="duplicateMethods">
        <xsl:for-each select="$methodsWithSameName">
          <xsl:if test="deep-equal($method/vm:signature/vm:parameter, ./vm:signature/vm:parameter)">
            <xsl:copy-of select="."/>
          </xsl:if>
        </xsl:for-each>
      </xsl:variable>
      <xsl:value-of select="count($duplicateMethods/vm:method) gt 1"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>


<xsl:function name="vm:isObjectRef" as="xs:boolean">
  <xsl:param name="type" as="xs:string"/>
  
  <xsl:value-of select="not($type='byte' or $type='short' or $type='int' or $type='float' or $type='long' or $type='double' or
                            $type='char' or $type='boolean' or $type='void')"/>
</xsl:function>


<xsl:function name="vm:typeID" as="xs:integer">
  <xsl:param name="type" as="xs:string"/>
  
  <xsl:choose>
    <xsl:when test="$type='boolean'">
      <xsl:value-of select="1"/>
    </xsl:when>
    <xsl:when test="$type='char'">
      <xsl:value-of select="2"/>
    </xsl:when>
    <xsl:when test="$type='byte'">
      <xsl:value-of select="3"/>
    </xsl:when>
    <xsl:when test="$type='short'">
      <xsl:value-of select="4"/>
    </xsl:when>
    <xsl:when test="$type='int'">
      <xsl:value-of select="5"/>
    </xsl:when>
    <xsl:when test="$type='float'">
      <xsl:value-of select="6"/>
    </xsl:when>
    <xsl:when test="$type='double'">
      <xsl:value-of select="7"/>
    </xsl:when>
    <xsl:when test="$type='long'">
      <xsl:value-of select="8"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="0"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>


<xsl:function name="vm:fixname">
  <xsl:param  name="a"/>
  <xsl:value-of  select="replace(replace(replace($a,'\$', '_'),'\.','_'), '\[\]', '_ARRAYTYPE')"/>
</xsl:function>
  

<xsl:function name="vm:cast">
  <xsl:param name="type"/>
  <xsl:choose>
    <xsl:when test="vm:isObjectRef($type)">
      <xsl:text>dynamic_cast&lt;</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="$type"/>
      </xsl:call-template>
      <xsl:text>&gt;</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>(</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="$type"/>
      </xsl:call-template>
      <xsl:text>)</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>


<xsl:function name="vm:cast-register">
  <xsl:param name="type"/>
  <xsl:param name="reg"/>
  <xsl:choose>
    <xsl:when test="vm:isObjectRef($type)">
      <xsl:text>dynamic_cast&lt;</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="$type"/>
      </xsl:call-template>
      <xsl:text>&gt;(_r</xsl:text>
      <xsl:value-of select="$reg"/>
      <xsl:text>.o)</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>((</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="$type"/>
      </xsl:call-template>
      <xsl:text>) _r</xsl:text>
      <xsl:value-of select="$reg"/>
      <xsl:call-template name="emitTypedAccess">
        <xsl:with-param name="type" select="$type"/>
      </xsl:call-template>
      <xsl:text>)</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>


<xsl:template match="vm:annotations">
  <!-- Ignore annotations -->
</xsl:template>


<!-- ********************************************************************************** -->
<!-- ********************************************************************************** -->
<!-- ********************************************************************************** -->
<!-- ********************************************************************************** -->
<!-- ********************************************************************************** -->
<!-- ********************************************************************************** -->
<!-- DEX Templates -->
<!-- http://www.netmite.com/android/mydroid/dalvik/docs/dalvik-bytecode.html -->
<!-- http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html -->


<xsl:template match="dex:code">
<xsl:text>{
</xsl:text>
  <xsl:if test="../@isStatic = 'true'">
    <xsl:text>    if (!__class_initialized) __init_class();
</xsl:text>
  </xsl:if>
  <xsl:apply-templates/>
  <xsl:text>}
</xsl:text>
</xsl:template>


<xsl:template match="vm:set-null">
  <xsl:text>    _r</xsl:text><xsl:value-of select="@num"/>
  <xsl:text>.o = JAVA_NULL;
</xsl:text>
</xsl:template>

<xsl:template match="vm:move-argument">
  <xsl:text>    _r</xsl:text><xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
 <xsl:if test="@sourceArg = 'self'">
   <xsl:text> = this;
</xsl:text>
 </xsl:if>
 <xsl:if test="@sourceArg != 'self'">
   <xsl:text> = n</xsl:text><xsl:value-of select="@sourceArg"/>
 <xsl:text>;
</xsl:text>
 </xsl:if>
</xsl:template>

<xsl:template match="vm:define-register">
  <xsl:choose>
 	<xsl:when test = "@vartype = 'register'">
 	  <xsl:text>    XMLVMElem _r</xsl:text><xsl:value-of select="@num"/><xsl:text>;
</xsl:text>
 	</xsl:when>
 	
 	  <xsl:when test = "@vartype = 'temp'">
        <xsl:text>    XMLVMElem _rtmp;
</xsl:text>
 	</xsl:when>
 	
 	<xsl:when test = "@vartype = 'exception'">
        <xsl:text>    java_lang_Object* _ex = JAVA_NULL;
</xsl:text>
 	</xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template match="dex:var">
  <!-- Do nothing -->
</xsl:template>

<xsl:template match="vm:source-position">
  <!-- TODO -->
</xsl:template>


<xsl:template match="dex:invoke-static|dex:invoke-static-range">
  <xsl:variable name="returnTypedAccess">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="dex:parameters/dex:return/@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    </xsl:text>
  <xsl:if test="dex:parameters/dex:return/@type != 'void'">
    <xsl:choose>
      <xsl:when test="dex:move-result">
        <xsl:text>_r</xsl:text>
        <xsl:value-of select="dex:move-result/@vx"/>
        <xsl:value-of select="$returnTypedAccess"/>
        <xsl:text> = </xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="vm:isObjectRef(dex:parameters/dex:return/@type)">
          <xsl:text>_rtmp.o = </xsl:text>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
  <xsl:value-of select="vm:fixname(@class-type)"/>
  <xsl:text>::</xsl:text>
  <xsl:value-of select="@method"/>
  <xsl:call-template name="appendDexSignature"/>
  <xsl:text>(</xsl:text>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:if test="position() != 1">
      <xsl:text>, </xsl:text>
    </xsl:if>
    <xsl:if test="vm:isObjectRef(@type)">
      <xsl:value-of select="vm:cast(@type)"/>
    </xsl:if>
    <xsl:text>(_r</xsl:text>
    <xsl:value-of select="@register"/>
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>)</xsl:text>
  </xsl:for-each>
  <xsl:text>);
</xsl:text>
</xsl:template>


<xsl:template match="dex:invoke-direct|dex:invoke-direct-range|dex:invoke-virtual|dex:invoke-virtual-range|dex:invoke-interface|dex:invoke-interface-range">
  <xsl:variable name="returnTypedAccess">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="dex:parameters/dex:return/@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    </xsl:text>
  <xsl:if test="dex:parameters/dex:return/@type != 'void'">
    <xsl:choose>
      <xsl:when test="dex:move-result">
        <xsl:text>_r</xsl:text>
        <xsl:value-of select="dex:move-result/@vx"/>
        <xsl:value-of select="$returnTypedAccess"/>
        <xsl:text> = </xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="vm:isObjectRef(dex:parameters/dex:return/@type)">
          <xsl:text>_rtmp.o = </xsl:text>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
  <xsl:text>(</xsl:text>
  <xsl:value-of select="vm:cast-register(@class-type, @register)"/>
  <xsl:text>)-&gt;</xsl:text>
  <xsl:call-template name="emitMethodName">
    <xsl:with-param name="name" select="@method"/>
    <xsl:with-param name="class-type" select="@class-type"/>
  </xsl:call-template>
  <xsl:call-template name="appendDexSignature"/>
  <xsl:text>(</xsl:text>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:if test="position() != 1">
      <xsl:text>, </xsl:text>
    </xsl:if>
    <xsl:if test="vm:isObjectRef(@type)">
      <xsl:value-of select="vm:cast(@type)"/>
    </xsl:if>
    <xsl:text>(_r</xsl:text>
    <xsl:value-of select="@register"/>
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>)</xsl:text>
  </xsl:for-each>
  <xsl:text>);
</xsl:text>
</xsl:template>


<xsl:template match="dex:invoke-super|dex:invoke-super-range">
  <xsl:variable name="returnTypedAccess">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="dex:parameters/dex:return/@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    </xsl:text>
  <xsl:if test="dex:parameters/dex:return/@type != 'void'">
    <xsl:choose>
      <xsl:when test="dex:move-result">
        <xsl:text>_r</xsl:text>
        <xsl:value-of select="dex:move-result/@vx"/>
        <xsl:value-of select="$returnTypedAccess"/>
        <xsl:text> = </xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="vm:isObjectRef(dex:parameters/dex:return/@type)">
          <xsl:text>_rtmp.o = </xsl:text>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
  <xsl:text>(</xsl:text>
  <xsl:value-of select="vm:cast-register(@class-type, @register)"/>
  <xsl:text>)-&gt;</xsl:text>
  <xsl:value-of select="vm:fixname(@class-type)"/>
  <xsl:text>::</xsl:text>
  <xsl:call-template name="emitMethodName">
    <xsl:with-param name="name" select="@method"/>
    <xsl:with-param name="class-type" select="@class-type"/>
  </xsl:call-template>
  <xsl:call-template name="appendDexSignature"/>
  <xsl:text>(</xsl:text>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:if test="position() != 1">
      <xsl:text>, </xsl:text>
    </xsl:if>
    <xsl:if test="vm:isObjectRef(@type)">
      <xsl:value-of select="vm:cast(@type)"/>
    </xsl:if>
    <xsl:text>(_r</xsl:text>
    <xsl:value-of select="@register"/>
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>)</xsl:text>
  </xsl:for-each>
  <xsl:text>);
</xsl:text>
</xsl:template>


<xsl:template match="dex:monitor-enter">
  <!-- TODO we can't map this to @synchronized {} because DEX may
       generate multiple monitor-exit for one monitor-enter -->
</xsl:template>


<xsl:template match="dex:monitor-exit">
  <!-- TODO we can't map this to @synchronized {} because DEX may
       generate multiple monitor-exit for one monitor-enter -->
</xsl:template>


<xsl:template match="dex:try-catch">
  <xsl:apply-templates/>
</xsl:template>


<xsl:template match="dex:try">
  <xsl:text>    try {
</xsl:text>
  <xsl:apply-templates/>
  <xsl:text>}
</xsl:text>
</xsl:template>

<xsl:template match="dex:catch">
    <xsl:text>    catch (</xsl:text>
    <xsl:value-of select="vm:fixname(@exception-type)"/>
    <xsl:text>*</xsl:text>
    <xsl:text> ex) {
        _ex = ex;
        goto label</xsl:text>
    <xsl:value-of select="@target"/>
    <xsl:text>;
    }
</xsl:text>
</xsl:template>



<xsl:template match="dex:catches">
  <!-- do nothing -->
</xsl:template>


<xsl:template match="dex:throw">
  <xsl:text>    _ex-&gt;__release();
    _ex = _r</xsl:text> <xsl:value-of select="@vx"/>.o<xsl:text>;
    _r</xsl:text><xsl:value-of select="@vx"/><xsl:text>.o = JAVA_NULL;
    throw((</xsl:text>
  <xsl:call-template name="emitType">
    <xsl:with-param name="type" select="@class-type"/>
  </xsl:call-template>
  <xsl:text>) _ex);
</xsl:text>
</xsl:template>


<xsl:template match="dex:move-exception">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = _ex; _ex = JAVA_NULL;
</xsl:text>
</xsl:template>


<xsl:template match="dex:add-int|dex:add-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i + _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:sub-int|dex:sub-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i - _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:mul-int|dex:mul-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i * _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:div-int|dex:div-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i / _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:rem-int|dex:rem-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i % _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:add-float|dex:add-float-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f + _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:sub-float|dex:sub-float-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f - _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:div-float|dex:div-float-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f / _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-float|dex:mul-float-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f * _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:add-double|dex:add-double-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d + _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:sub-double|dex:sub-double-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d - _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:div-double|dex:div-double-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d / _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:add-long|dex:add-long-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l + _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>


<xsl:template match="dex:sub-long|dex:sub-long-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l - _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-long|dex:mul-long-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l * _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:div-long|dex:div-long-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l / _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>


<xsl:template match="dex:rem-long|dex:rem-long-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l % _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:and-int|dex:and-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &amp; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:and-long|dex:and-long-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l &amp; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>


<xsl:template match="dex:shl-int|dex:shl-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &lt;&lt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:shl-long|dex:shl-long-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l &lt;&lt; (0x3f &amp; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l);
</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-double|dex:mul-double-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d * _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:and-int-lit8|dex:and-int-lit16">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &amp; </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:shl-int-lit8|dex:shl-int-lit16">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &lt;&lt; </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:shr-int-lit8|dex:shr-int-lit16">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &gt;&gt; </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:shr-int|dex:shr-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &gt;&gt; (0x1f &amp; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i);
</xsl:text>
</xsl:template>


<xsl:template match="dex:shr-long|dex:shr-long-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l &gt;&gt; (0x3f &amp; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l);
</xsl:text>
</xsl:template>


<xsl:template match="dex:ushr-int-lit8|dex:ushr-int-lit16">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &gt;&gt; (0x1f &amp; </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>);
</xsl:text>
</xsl:template>


<xsl:template match="dex:ushr-int|dex:ushr-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = ((unsigned int) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i) &gt;&gt; (0x1f &amp; ((unsigned int) _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i));
</xsl:text>
</xsl:template>


<xsl:template match="dex:ushr-long|dex:ushr-long-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = ((unsigned long) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l) &gt;&gt; (0x3f &amp; ((unsigned long) _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l));
</xsl:text>
</xsl:template>


<xsl:template match="dex:or-int-lit8|dex:or-int-lit16">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i | </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:xor-int-lit8|dex:xor-int-lit16">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i ^ </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:xor-int|dex:xor-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i ^ _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:xor-long|dex:xor-long-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l ^ _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:or-int|dex:or-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i | _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:or-long|dex:or-long-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l | _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:return-void">
  <xsl:if test="@catchesException = 'true'">
    <xsl:text>    _ex-&gt;__release();
</xsl:text>
  </xsl:if>
  <xsl:text>    return;
</xsl:text>
</xsl:template>


<xsl:template match="dex:return|dex:return-wide|dex:return-object">
  <xsl:if test="@catchesException = 'true'">
    <xsl:text>    _ex-&gt;__release();
</xsl:text>
  </xsl:if>
  <xsl:variable name="return-type" select="ancestor::vm:method/vm:signature/vm:return/@type" />
  <xsl:text>    return _r</xsl:text>
  <xsl:value-of select="@vx" />
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="$return-type" />
  </xsl:call-template>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:new-instance">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx" />
  <xsl:text>.o = new </xsl:text>
  <xsl:value-of select="vm:fixname(@value)" />
  <xsl:text>::</xsl:text>
  <xsl:value-of select="vm:fixname(@value)" />
  <xsl:text>();
</xsl:text>
</xsl:template>


<xsl:template match="dex:iget|dex:iget-wide|dex:iget-boolean|dex:iget-byte|dex:iget-char|dex:iget-short">
  <xsl:variable name="m">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@member-type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:value-of select="$m"/>
  <xsl:text> = </xsl:text>
  <xsl:value-of select="vm:cast-register(@class-type, @vy)"/>
  <xsl:text>-></xsl:text>
  <xsl:value-of select="vm:fixname(@member-name)"/>
  <xsl:text>_</xsl:text>
  <xsl:value-of select="vm:fixname(@member-type)"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:iget-object">
  <xsl:variable name="m">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@member-type" />
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx" />
  <xsl:value-of select="$m" />
  <xsl:text> = </xsl:text>
  <xsl:value-of select="vm:cast-register(@class-type, @vy)"/>
  <xsl:text>-></xsl:text>
  <xsl:value-of select="vm:fixname(@member-name)" />
  <xsl:text>_</xsl:text>
  <xsl:value-of select="vm:fixname(@member-type)" />
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:iput|dex:iput-wide|dex:iput-boolean|dex:iput-byte|dex:iput-char|dex:iput-short">
  <xsl:variable name="m">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@member-type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    </xsl:text>
  <xsl:value-of select="vm:cast-register(@class-type, @vy)"/>
  <xsl:text>-></xsl:text>
  <xsl:value-of select="vm:fixname(@member-name)"/>
  <xsl:text>_</xsl:text>
  <xsl:value-of select="vm:fixname(@member-type)"/>
  <xsl:text> = </xsl:text>
  <xsl:text> _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:value-of select="$m"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="vm:tmp-equals-r">
  <xsl:text>    _rtmp.o =  _r</xsl:text>
  <xsl:value-of select="@reg" />
  <xsl:text>.o;
</xsl:text>
</xsl:template>
  

<xsl:template match="vm:comment">
  <xsl:text>    //INFO: </xsl:text>
    <xsl:value-of select="@text" />
  <xsl:text>
  </xsl:text>
</xsl:template>

<xsl:template match="vm:reg-release">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@reg" />
  <xsl:text>.o-&gt;__release();
</xsl:text>
</xsl:template>

<xsl:template match="vm:reg-retain">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@reg" />
  <xsl:text>.o-&gt;__retain();
</xsl:text>
</xsl:template>
  
<xsl:template match="vm:i-release">
    <xsl:variable name="m">
      <xsl:call-template name="emitTypedAccess">
        <xsl:with-param name="type" select="@member-type" />
      </xsl:call-template>
    </xsl:variable>
  <xsl:text>   </xsl:text>
  <xsl:value-of select="vm:cast-register(@class-type, @vy)"/>
  <xsl:text>-></xsl:text>
  <xsl:value-of select="vm:fixname(@member-name)" />
  <xsl:text>_</xsl:text>
  <xsl:value-of select="vm:fixname(@member-type)" />
  <xsl:text>-&gt;__release();
</xsl:text>
</xsl:template>

<xsl:template match="dex:iput-object">
  <xsl:text>    </xsl:text>
  <xsl:value-of select="vm:cast-register(@class-type, @vy)"/>
  <xsl:text>-></xsl:text>
  <xsl:value-of select="vm:fixname(@member-name)" />
  <xsl:text>_</xsl:text>
  <xsl:value-of select="vm:fixname(@member-type)" />
  <xsl:text> = </xsl:text>
  <xsl:value-of select="vm:cast-register(@member-type, @vx)"/>
  <xsl:text>;
</xsl:text>
</xsl:template>



<xsl:template match="dex:sget|dex:sget-wide|dex:sget-boolean|dex:sget-char|dex:sget-object">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@member-type"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:value-of select="vm:fixname(@class-type)"/>
  <xsl:text>::_GET_</xsl:text>
  <xsl:value-of select="vm:fixname(@member-name)"/>
  <xsl:text>();
</xsl:text>
</xsl:template>

<xsl:template match="vm:s-release">
    <xsl:text>    </xsl:text>
    <xsl:value-of select="vm:fixname(@class-type)" />
    <xsl:text>::_RELEASE_</xsl:text>
    <xsl:value-of select="vm:fixname(@member-name)" />
    <xsl:text>();
</xsl:text>
</xsl:template>

<xsl:template match="dex:sput|dex:sput-wide|dex:sput-boolean|dex:sput-char|dex:sput-object">
  <xsl:text>    </xsl:text>
  <xsl:value-of select="vm:fixname(@class-type)"/>
  <xsl:text>::_PUT_</xsl:text>
  <xsl:value-of select="vm:fixname(@member-name)"/>
  <xsl:text>(</xsl:text>
  <xsl:value-of select="vm:cast-register(@member-type, @vx)"/>
  <xsl:text>);
</xsl:text>
</xsl:template>



<xsl:template match="dex:const-4[@kind='known-null']|dex:const-8[@kind='known-null']|dex:const-16[@kind='known-null']"> 
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = JAVA_NULL;
</xsl:text>
</xsl:template>


<xsl:template match="dex:const|dex:const-4|dex:const-16|dex:const-wide|dex:const-wide-16|dex:const-wide-32|dex:const-high16|dex:const-wide-high16"> 
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@type"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:value-of select="@value"/>
  <xs:text>;
</xs:text>
</xsl:template>


<xsl:template match="dex:const-string"> 
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = new java_lang_String();
    </xsl:text>
  <xsl:value-of select="vm:cast-register('java.lang.String', @vx)"/>
  <xsl:text>->__init_java_lang_String___char_ARRAYTYPE(XMLVMArray::createFromString("</xsl:text>
  <xsl:value-of select="@value"/>
  <xs:text>"));
</xs:text>
</xsl:template>


<xsl:template match="dex:const-class"> 
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = </xsl:text>
  <xsl:value-of select="vm:fixname(@value)"/>
  <xs:text>->getClass__();
</xs:text>
</xsl:template>


<xsl:template match="dex:float-to-int">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (JAVA_INT) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:float-to-long">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = (JAVA_LONG) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:float-to-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = (JAVA_DOUBLE) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-byte">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &lt;&lt; 24) &gt;&gt; 24;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-short">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &lt;&lt; 16) &gt;&gt; 16;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = (JAVA_FLOAT) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-long">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = (JAVA_LONG) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = (JAVA_DOUBLE) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-char">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i &amp; 0xffff;
</xsl:text>
</xsl:template>


<xsl:template match="dex:long-to-int">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (JAVA_INT) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>


<xsl:template match="dex:long-to-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = (JAVA_FLOAT) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>


<xsl:template match="dex:long-to-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = (JAVA_DOUBLE) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>


<xsl:template match="dex:double-to-long">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = (JAVA_LONG) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:double-to-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = (JAVA_FLOAT) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:double-to-int">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (JAVA_INT) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpl-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpg-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpl-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpg-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmp-long">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.l ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-int">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = -_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-long">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = -_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.l;
</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = -_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = -_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:add-int-lit8|dex:add-int-lit16">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i + </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-int-lit8|dex:mul-int-lit16">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i * </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:div-int-lit8|dex:div-int-lit16">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i / </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:rem-int-lit8|dex:rem-int-lit16">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i % </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:label">
  <xsl:text>    label</xsl:text>
  <xsl:value-of select="@id"/>
  <xsl:text>:;
</xsl:text>
</xsl:template>


<xsl:template match="dex:goto|dex:goto-16">
  <xsl:text>    goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-eqz">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:choose>
    <xsl:when test="vm:isObjectRef(@vx-type)">
      <xsl:text>.o == JAVA_NULL</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="emitTypedAccess">
        <xsl:with-param name="type" select="@vx-type"/>
      </xsl:call-template>
      <xsl:text> == 0</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-nez">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:choose>
    <xsl:when test="vm:isObjectRef(@vx-type)">
      <xsl:text>.o != JAVA_NULL</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="emitTypedAccess">
        <xsl:with-param name="type" select="@vx-type"/>
      </xsl:call-template>
      <xsl:text> != 0</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-gez">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt;= 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ltz">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt; 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-lez">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt;= 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-gtz">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt; 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ge">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt;= _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-gt">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt; _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-le">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt;= _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-lt">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt; _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-eq">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> == _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ne">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> != _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:sparse-switch|dex:packed-switch">
  <xsl:text>    switch (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i) {
</xsl:text>
  <xsl:for-each select="dex:case">
    <xsl:text>    case </xsl:text>
    <xsl:value-of select="@key"/>
    <xsl:text>: goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;
</xsl:text>
  </xsl:for-each>
  <xsl:text>    }
</xsl:text>
</xsl:template>


<xsl:template match="dex:filled-new-array|dex:filled-new-array-range">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="dex:move-result/@vx"/>
  <xsl:text>.o = ((XMLVMElem[]) {</xsl:text>
  <xsl:for-each select="dex:value">
    <xsl:text>_r</xsl:text>
    <xsl:value-of select="@register"/>
    <xsl:text>, </xsl:text>
  </xsl:for-each>
  <xsl:text>});
</xsl:text>
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="dex:move-result/@vx"/>
  <xsl:text>.o = XMLVMArray::createSingleDimension(5, </xsl:text>
  <xsl:value-of select="count(dex:value)"/>
  <xsl:text>, _r</xsl:text>
  <xsl:value-of select="dex:move-result/@vx"/>
  <xsl:text>.o);
</xsl:text>
</xsl:template>


<xsl:template match="dex:fill-array-data">
  <xsl:text>    XMLVMArray::fillArray(</xsl:text>
  <xsl:value-of select="vm:cast-register('XMLVMArray', @vx)"/>
  <xsl:text>, (</xsl:text>
  <xsl:value-of select="@vx-type"/>
  <xsl:text>){</xsl:text>
  <xsl:for-each select="dex:constant">
    <xsl:value-of select="@value"/>
    <xsl:text>, </xsl:text>
  </xsl:for-each>
  <xsl:text>});
</xsl:text>
</xsl:template>


<xsl:template match="dex:new-array">
  <xsl:variable name="base-type" select="replace(@value, '\[\]', '')"/>
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = XMLVMArray::createSingleDimension(</xsl:text>
  <xsl:value-of select="vm:typeID($base-type)"/>
  <xsl:text>, _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i);
</xsl:text>
</xsl:template>


<xsl:template match="dex:array-length">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = </xsl:text>
  <xsl:value-of select="vm:cast-register('XMLVMArray', @vy)"/>
  <xsl:text>->count();
</xsl:text>
</xsl:template>


<xsl:template match="dex:aget|dex:aget-wide|dex:aget-boolean|dex:aget-byte|dex:aget-char|dex:aget-short">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:value-of select="vm:cast-register('XMLVMArray', @vy)"/>
  <xsl:text>->array</xsl:text>
  <xsl:call-template name="emitTypedArrayAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>[_r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i];
</xsl:text>
</xsl:template>


<xsl:template match="dex:aget-object">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx" />
  <xsl:text>.o = </xsl:text>
  <xsl:value-of select="vm:cast-register('XMLVMArray', @vy)"/>
  <xsl:text>->array.o[_r</xsl:text>
  <xsl:value-of select="@vz" />
  <xsl:text>.i];
</xsl:text>
</xsl:template>


<xsl:template match="dex:aput|dex:aput-wide|dex:aput-boolean|dex:aput-char|dex:aput-byte|dex:aput-short">
  <xsl:text>    </xsl:text>
  <xsl:value-of select="vm:cast-register('XMLVMArray', @vy)"/>
  <xsl:text>->array</xsl:text>
  <xsl:call-template name="emitTypedArrayAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>[_r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i] = _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="vm:a-release">
  <xsl:text>    </xsl:text>
  <xsl:value-of select="vm:cast-register('XMLVMArray', @vy)"/>
  <xsl:text>->array.o[_r</xsl:text>
  <xsl:value-of select="@vz" />
  <xsl:text>.i]->__release();
</xsl:text>
</xsl:template>
  
<xsl:template match="dex:aput-object">
  <xsl:text>    </xsl:text>
  <xsl:value-of select="vm:cast-register('XMLVMArray', @vy)"/>
  <xsl:text>->array.o[_r</xsl:text>
  <xsl:value-of select="@vz" />
  <xsl:text>.i] = _r</xsl:text>
  <xsl:value-of select="@vx" />
  <xsl:text>.o;
</xsl:text>
</xsl:template>


<xsl:template match="dex:check-cast">
  <!-- TODO should do a runtime type check -->
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.o;
</xsl:text>
</xsl:template>


<xsl:template match="dex:instance-of">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.o != JAVA_NULL &amp;&amp; 
        (dynamic_cast&lt;</xsl:text>
  <xsl:value-of select="vm:fixname(@value)"/>
  <xsl:text>*&gt;(_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.o) != (</xsl:text>
  <xsl:value-of select="vm:fixname(@value)"/>
  <xsl:text>*) 0)) ? 1 : 0;
</xsl:text>
</xsl:template>



<xsl:template match="dex:move|dex:move-from16|dex:move-wide|dex:move-wide-from16|dex:move-object|dex:move-object-from16">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text> = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>;
</xsl:text>
</xsl:template>





<xsl:template name="appendDexSignature">
  <xsl:text>__</xsl:text>
  <xsl:choose>
    <xsl:when test="count(dex:parameters/dex:parameter) != 0">
      <xsl:for-each select="dex:parameters/dex:parameter">
        <xsl:text>_</xsl:text>
        <xsl:value-of select="replace(vm:fixname(@type), '\[\]', '_ARRAYTYPE')"/>
      </xsl:for-each>
    </xsl:when>
  </xsl:choose>
</xsl:template>



<!--
   Default template. If the XMLVM file should contain an instruction
   that is not handled by this stylesheet, this default template
   will make sure we notice it by writing a special error function
   to the output stream.
-->
<xsl:template match="*">
  <xsl:text>      ERROR("</xsl:text>
  <xsl:value-of select="name()"/>
    <xsl:text>");
</xsl:text>
  <xsl:message select="."/>
</xsl:template>


</xsl:stylesheet>
