<?xml version="1.0"?>

<!--
 *
 *  XMLVM - An XML-based Programming Language
 *  Copyright (c) 2004-2005 by Arno Puder
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *  For more information, visit the XMLVM Home Page at
 *  http://www.xml11.org/xmlvm/
 *
-->

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:vm="http://xmlvm.org"
                xmlns:jvm="http://xmlvm.org/jvm"
                version="2.0">

<xsl:output method="text"/>


<xsl:template match="vm:xmlvm">
	<xsl:text>
        
// Automatically generated by XMLVM. DO NOT EDIT!

#include "xmlvm.h"
#include "default.h"
	</xsl:text>
	<xsl:apply-templates/>
	<xsl:for-each select="vm:class/vm:method">
		<xsl:if test="@name = 'main'">
<xsl:text>
int main(int argc, char* argv[])
{
    XMLVM::Object_Ptr&lt; XMLVM::Array&lt; java::lang::String &gt; &gt; args = new XMLVM::Array&lt; java::lang::String &gt;(argc-1);
    for(int i=0; i&lt;argc-1; i++){
        (*args)[i] = new java::lang::String(argv[i+1]);
    }
    </xsl:text>
<xsl:value-of select="../@name"/>
<xsl:text>::</xsl:text>
<xsl:value-of select="@name"/>
<xsl:text>(args);
    return 0;
}
</xsl:text>
		</xsl:if>
	</xsl:for-each>
</xsl:template>



<xsl:template match="vm:class">
	<xsl:text>
class </xsl:text><xsl:value-of select="@name"/><xsl:text>;
typedef </xsl:text><xsl:value-of select="@name"/><xsl:text>* </xsl:text>
<xsl:value-of select="@name"/><xsl:text>_ref;</xsl:text>
    <xsl:text>
class </xsl:text><xsl:value-of select="@name"/><xsl:text>
        : </xsl:text>
	<xsl:choose>
		<xsl:when test="@isInterface = 'true'">
			<xsl:if test="@interfaces = ''">
				<xsl:text>virtual public java::lang::Interface</xsl:text>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>public </xsl:text>
			<xsl:call-template name="emitScopedName">
				<xsl:with-param name="string" select="@extends"/>
			</xsl:call-template>
			<xsl:if test="@interfaces != ''">
				<xsl:text>,</xsl:text>
			</xsl:if>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:call-template name="parseInterfaces">
		<xsl:with-param name="interfaces" select="@interfaces"/>
	</xsl:call-template>
	<xsl:text>
{
public:
</xsl:text>
<xsl:apply-templates/>
<xsl:text>
};
</xsl:text>

	<xsl:for-each select="vm:field">
		<xsl:if test="@isStatic = 'true'">
	<xsl:text>
XMLVM::Object_Ptr&lt; </xsl:text>
			<xsl:call-template name="emitTypeWORef">
				<xsl:with-param name="type" select="@type"/>
			</xsl:call-template>
			<xsl:text> &gt; </xsl:text>
			<xsl:value-of select="../@name"/>
			<xsl:text>::</xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> = XMLVM::NULL_POINTER;</xsl:text>
		</xsl:if>
	</xsl:for-each>

<xsl:text>

class </xsl:text><xsl:value-of select="@name"/><xsl:text>_Loader {
	public:
		</xsl:text><xsl:value-of select="@name"/><xsl:text>_Loader() {
			</xsl:text>
			<xsl:value-of select="@name"/><xsl:text>::__clinit();
		}
};
static </xsl:text><xsl:value-of select="@name"/><xsl:text>_Loader </xsl:text>
<xsl:value-of select="@name"/><xsl:text>_loader;

</xsl:text>
</xsl:template>


<xsl:template name="parseInterfaces">
	<xsl:param name="interfaces" />
	<xsl:if test="$interfaces != ''">
		<xsl:text> virtual public </xsl:text>
		<xsl:choose>
			<xsl:when test="contains($interfaces, ',')">
				<xsl:call-template name="emitTypeWORef" >
					<xsl:with-param name="type">
						<xsl:value-of select="substring-before($interfaces, ',')"/>
					</xsl:with-param>
				</xsl:call-template>
				<xsl:text>,</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="emitTypeWORef" >
					<xsl:with-param name="type">
						<xsl:value-of select="$interfaces" />
					</xsl:with-param>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:call-template name="parseInterfaces">
			<xsl:with-param name="interfaces" select="substring-after($interfaces, ',')"/>
		</xsl:call-template>
	</xsl:if>
</xsl:template>


<xsl:template match="vm:method">
    <xsl:text>
    </xsl:text>
	<xsl:if test="@isAbstract = 'true'">
		<xsl:text>virtual </xsl:text>
	</xsl:if>
	<xsl:call-template name="emitPrototype"/>
		<xsl:choose>
			<xsl:when test="@isAbstract = 'true'">
				<xsl:text> = 0;</xsl:text>
			</xsl:when>
			<xsl:otherwise>
<xsl:text>
    {
        XMLVM::Locals locals(</xsl:text>
		<xsl:value-of select="@locals"/>
		<xsl:text>);
    	XMLVM::Stack stack(</xsl:text>
		<xsl:value-of select="@stack"/>
		<xsl:text>);
    	XMLVM::Object_Ptr&lt; java::lang::Object &gt; op1;
    	XMLVM::Object_Ptr&lt; java::lang::Object &gt; op2;</xsl:text>
	<xsl:call-template name="initLocals"/>
	<xsl:apply-templates/>

<xsl:text>
    	label998:
	    cout &lt;&lt; "jsr/ret.  Terminating." &lt;&lt; endl;
	    exit(1);
    }
</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
</xsl:template>


<xsl:template match="vm:signature">
	<!-- do nothing -->
</xsl:template>


<xsl:template match="vm:code">
	<xsl:apply-templates/>
</xsl:template>

<xsl:template match="jvm:var">
	<!-- do nothing -->
</xsl:template>


<!--
    =============================================================================
	All templates below create code for the various Java VM bytecode instructions
	=============================================================================
-->


<!-- label -->
<xsl:template match="jvm:label">
    <xsl:text>
        label</xsl:text>
	<xsl:value-of select="@id"/>
	<xsl:text>:</xsl:text>
</xsl:template>



<!-- aaload -->
<xsl:template match="jvm:aaload">
    <xsl:text>
        op1 = stack.pop();
        op2 = stack.pop();
        stack.push( ((XMLVM::ArrayBase_ref)op2)->get(*((java::lang::INT_ref)op1)) );
    </xsl:text>
</xsl:template>



<!-- aconst_null -->
<xsl:template match="jvm:aconst_null">
    <xsl:text>
        stack.push(XMLVM::NULL_POINTER);</xsl:text>
</xsl:template>



<!-- athrow -->
<xsl:template match="jvm:athrow">
	<xsl:text>
        op1 = stack.pop();
</xsl:text>
    <xsl:choose>
	<xsl:when test="@type = ''">
		<xsl:text>
        throw *(java::lang::Exception_ref) op1;
</xsl:text>
	</xsl:when>
	<xsl:otherwise>
    <xsl:text>
        throw *(</xsl:text>
    <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>) op1;</xsl:text>
	</xsl:otherwise>
    </xsl:choose>
</xsl:template>



<!-- bipush, sipush -->
<xsl:template match="jvm:bipush|jvm:sipush">
	<xsl:text>
        stack.push(new java::lang::INT(</xsl:text>
	<xsl:value-of select="@value"/>
	<xsl:text>));</xsl:text>
</xsl:template>



<!-- catch -->
<xsl:template match="jvm:catch">
    <xsl:text>
        try {</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>} catch (</xsl:text>
    <xsl:call-template name="emitTypeWORef">
        <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text> __ex) {
            stack.clear();
            stack.push(new </xsl:text>
    <xsl:call-template name="emitTypeWORef">
        <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>(__ex));
            goto label</xsl:text>
    <xsl:value-of select="@using"/>
    <xsl:text>;
        }</xsl:text>
</xsl:template>



<!-- dup -->
<xsl:template match="jvm:dup">
	<xsl:text>
        stack.dup();</xsl:text>
</xsl:template>




<!-- ret -->
<xsl:template match="jvm:ret">
	<xsl:text>
        goto label998;// ret</xsl:text>
</xsl:template>


<!-- field -->
<xsl:template match="vm:field">
	<xsl:if test="@isStatic = 'true'">
		<xsl:text>static </xsl:text>
	</xsl:if>
    <xsl:text>
    XMLVM::Object_Ptr&lt; </xsl:text>
	<xsl:call-template name="emitTypeWORef">
		<xsl:with-param name="type" select="@type"/>
	</xsl:call-template>
	<xsl:text> &gt; </xsl:text>
	<xsl:value-of select="@name"/>
	<xsl:text>;</xsl:text>
</xsl:template>



<!-- getfield -->
<xsl:template match="jvm:getfield">
    <xsl:text>
        op1 = stack.pop();
        stack.push(((</xsl:text>
	    <xsl:call-template name="emitType">
		<xsl:with-param name="type" select="@class-type"/>
	    </xsl:call-template>
    <xsl:text>) op1)-&gt;</xsl:text>
    <xsl:value-of select="@field"/>
    <xsl:text>);</xsl:text>
</xsl:template>



<!-- getstatic -->
<xsl:template match="jvm:getstatic">
	<xsl:text>
        stack.push(</xsl:text>
	<xsl:call-template name="emitScopedName">
		<xsl:with-param name="string" select="@class-type"/>
	</xsl:call-template>
	<xsl:text>::</xsl:text>
	<xsl:value-of select="@field"/>
	<xsl:text>);</xsl:text>
</xsl:template>



<!-- goto -->
<xsl:template match="jvm:goto">
	<xsl:text>
        goto label</xsl:text>
	<xsl:value-of select="@label"/>
	<xsl:text>;</xsl:text>
</xsl:template>



<!-- iconst -->
<xsl:template match="jvm:iconst">
	<xsl:text>
        stack.push(new java::lang::INT(</xsl:text>
	<xsl:value-of select="@value"/>
	<xsl:text>));</xsl:text>
</xsl:template>



<!-- if_icmpge -->
<xsl:template match="jvm:if_icmpge">
	<xsl:text>
        op2 = stack.pop();
        op1 = stack.pop();
        if ( (*(java::lang::INT_ref)op1) &gt;= (*(java::lang::INT_ref)op2) ) goto label</xsl:text>
	<xsl:value-of select="@label"/>
	<xsl:text>;</xsl:text>
</xsl:template>



<!-- if_icmplt -->
<xsl:template match="jvm:if_icmplt">
	<xsl:text>
        op2 = stack.pop();
        op1 = stack.pop();
        if ( (*(java::lang::INT_ref)op1) &lt; (*(java::lang::INT_ref)op2) ) goto label</xsl:text>
	<xsl:value-of select="@label"/>
	<xsl:text>;</xsl:text>
</xsl:template>



<!-- ifnonnull -->
<xsl:template match="jvm:ifnonnull">
	<xsl:text>
        op1 = stack.pop();
        if ( op1 != XMLVM::NULL_POINTER ) 
            goto label</xsl:text>
	<xsl:value-of select="@label"/>
	<xsl:text>;</xsl:text>
</xsl:template>



<!-- if_icmpne -->
<xsl:template match="jvm:if_icmpne">
	<xsl:text>
        op2 = stack.pop();
        op1 = stack.pop();
        if ( (*(java::lang::INT_ref)op1) != (*(java::lang::INT_ref)op2) ) goto label</xsl:text>
	<xsl:value-of select="@label"/>
	<xsl:text>;</xsl:text>
</xsl:template>



<!-- iadd -->
<xsl:template match="jvm:iadd">
	<xsl:text>
        op2 = stack.pop();
        op1 = stack.pop();
        stack.push(new java::lang::INT( (*( (java::lang::INT_ref)op1)) + (*( (java::lang::INT_ref) op2))));</xsl:text>
</xsl:template>


<!-- idiv -->
<xsl:template match="jvm:idiv">
	<xsl:text>
        op2 = stack.pop();
        op1 = stack.pop();
        stack.push(new java::lang::INT( (*( (java::lang::INT_ref)op1)) / (*( (java::lang::INT_ref) op2))));</xsl:text>
</xsl:template>


<!-- ifeq -->
<xsl:template match="jvm:ifeq">
    <xsl:text>
        if ( (*(java::lang::INT_ref)stack.pop()) == 0) goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;</xsl:text>
</xsl:template>

<!-- ifne -->
<xsl:template match="jvm:ifne">
    <xsl:text>
        if ( (*(java::lang::INT_ref)stack.pop()) != 0) goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;</xsl:text>
</xsl:template>

<!-- iflt -->
<xsl:template match="jvm:iflt">
    <xsl:text>
        if ( (*(java::lang::INT_ref)stack.pop()) &lt; 0) goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;</xsl:text>
</xsl:template>

<!-- ifge -->
<xsl:template match="jvm:ifge">
    <xsl:text>
        if ( (*(java::lang::INT_ref)stack.pop()) &gt;= 0) goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;</xsl:text>
</xsl:template>

<!-- ifgt -->
<xsl:template match="jvm:ifgt">
    <xsl:text>
        if ( (*(java::lang::INT_ref)stack.pop()) &gt; 0) goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;</xsl:text>
</xsl:template>

<!-- ifle -->
<xsl:template match="jvm:ifle">
    <xsl:text>
        if ( (*(java::lang::INT_ref)stack.pop()) &lt;= 0) goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;</xsl:text>
</xsl:template>



<!-- iinc -->
<xsl:template match="jvm:iinc">
	<xsl:text>
        ( *( (java::lang::INT_ref) (locals[</xsl:text>
	<xsl:value-of select="@index"/>
	<xsl:text>]))).value += </xsl:text>
	<xsl:value-of select="@incr"/>
	<xsl:text>;</xsl:text>
</xsl:template>


<!-- iload, aload -->
<xsl:template match="jvm:iload|jvm:aload">
	<xsl:text>
        stack.push(locals[</xsl:text>
	<xsl:value-of select="@index"/>
	<xsl:text>]);</xsl:text>
</xsl:template>



<!-- imul -->
<xsl:template match="jvm:imul">
	<xsl:text>
        op2 = stack.pop();
        op1 = stack.pop();
        stack.push(new java::lang::INT( (*( (java::lang::INT_ref)op1)) *  (*( (java::lang::INT_ref) op2))));</xsl:text>
</xsl:template>



<!-- invokestatic -->
<xsl:template match="jvm:invokestatic">
    <xsl:text>
        </xsl:text>
	<xsl:if test="vm:signature/vm:return/@type != 'void'">
		<xsl:text>op1 = </xsl:text>
	</xsl:if>
	<xsl:call-template name="emitScopedName">
	    <xsl:with-param name="string" select="@class-type"/>
	</xsl:call-template>
	<xsl:text>::</xsl:text>
	<xsl:call-template name="emitMethodName">
		<xsl:with-param name="name" select="@method"/>
	</xsl:call-template>
	<xsl:text>(</xsl:text>
	<xsl:for-each select="vm:signature/vm:parameter">
		<xsl:if test="position() != 1">
			<xsl:text>, </xsl:text>
		</xsl:if>
		<xsl:text>(</xsl:text>
		<xsl:call-template name="emitType">
			<xsl:with-param name="type" select="@type"/>
		</xsl:call-template>
		<xsl:text>) stack.top(</xsl:text>
		<xsl:value-of select="count(../vm:parameter) - position()"/>
		<xsl:text>)</xsl:text>
	</xsl:for-each>
	<xsl:text>);</xsl:text>
	<xsl:text>
        stack.remove(</xsl:text>
	<xsl:value-of select="count(vm:signature/vm:parameter)"/>
	<xsl:text>);</xsl:text>
	<xsl:if test="vm:signature/vm:return/@type != 'void'">
		<xsl:text>
        stack.push(op1);</xsl:text>
	</xsl:if>
</xsl:template>



<!-- invokevirtual, invokespecial, invokeinterface -->
<xsl:template match="jvm:invokevirtual|jvm:invokespecial|jvm:invokeinterface">
    <xsl:text>
        </xsl:text>
	<xsl:if test="vm:signature/vm:return/@type != 'void'">
		<xsl:text>op1 = (java::lang::Object_ref) </xsl:text>
	</xsl:if>
	<xsl:text>((</xsl:text>
	<xsl:call-template name="emitType">
	    <xsl:with-param name="type" select="@class-type"/>
	</xsl:call-template>
	<xsl:text>) stack.top(</xsl:text>
    <xsl:value-of select="count(vm:signature/vm:parameter)"/>
    <xsl:text>))-></xsl:text>
	<xsl:call-template name="emitMethodName">
		<xsl:with-param name="name" select="@method"/>
	</xsl:call-template>
	<xsl:text>(</xsl:text>
	<xsl:for-each select="vm:signature/vm:parameter">
		<xsl:if test="position() != 1">
			<xsl:text>, </xsl:text>
		</xsl:if>
		<xsl:text>(</xsl:text>
		<xsl:call-template name="emitType">
			<xsl:with-param name="type" select="@type"/>
		</xsl:call-template>
		<xsl:text>) stack.top(</xsl:text>
		<xsl:value-of select="count(../vm:parameter) - position()"/>
		<xsl:text>)</xsl:text>
	</xsl:for-each>
	<xsl:text>);</xsl:text>	
	<xsl:text>
        stack.remove(</xsl:text>
	<xsl:value-of select="count(vm:signature/vm:parameter) + 1"/>
	<xsl:text>);</xsl:text>
	<xsl:if test="vm:signature/vm:return/@type != 'void'">
		<xsl:text>
        stack.push(op1);</xsl:text>
	</xsl:if>
</xsl:template>
	


<!-- ireturn|areturn -->	
<xsl:template match="jvm:ireturn|jvm:areturn">
	<xsl:text>
        return stack.pop();</xsl:text>
</xsl:template>



<!-- istore, astore -->
<xsl:template match="jvm:istore|jvm:astore">
	<xsl:text>
        locals[</xsl:text>
	<xsl:value-of select="@index"/>
	<xsl:text>] = stack.pop();</xsl:text>
</xsl:template>



<!-- isub -->
<xsl:template match="jvm:isub">
	<xsl:text>
        op2 = stack.pop();
        op1 = stack.pop();
        stack.push(new java::lang::INT( (*( (java::lang::INT_ref)op1)) -  (*( (java::lang::INT_ref) op2))));</xsl:text>
</xsl:template>



<!-- ldc -->
<xsl:template match="jvm:ldc">
    <xsl:text>
        </xsl:text>
	<xsl:choose>
		<xsl:when test="@type = 'java.lang.String'">
			<xsl:text>stack.push( new java::lang::String("</xsl:text>
			<xsl:value-of select="@value"/>
			<xsl:text>"));</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>ldc_error();</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>



<!-- new -->
<xsl:template match="jvm:new">
    <xsl:choose>
        <xsl:when test="count(vm:signature) = 0">
            <xsl:text>
        stack.push(new </xsl:text>
        	<xsl:call-template name="emitScopedName">
        		<xsl:with-param name="string" select="@type"/>
        	</xsl:call-template>
        	<xsl:text>());</xsl:text>
    </xsl:when>

    <xsl:otherwise>
        <xsl:text>
    	op1 = (java::lang::Object_ref) new </xsl:text>
    	<xsl:call-template name="emitScopedName">
    	    <xsl:with-param name="string" select="@type"/>
    	</xsl:call-template>
        <xsl:text>();
        ((</xsl:text>
    	<xsl:call-template name="emitType">
    	    <xsl:with-param name="type" select="@type"/>
    	</xsl:call-template>
        <xsl:text>) op1)->__init(</xsl:text>
    	<xsl:for-each select="vm:signature/vm:parameter">
    		<xsl:if test="position() != 1">
    			<xsl:text>, </xsl:text>
    		</xsl:if>
    		<xsl:text>(</xsl:text>
    		<xsl:call-template name="emitType">
    			<xsl:with-param name="type" select="@type"/>
    		</xsl:call-template>
    		<xsl:text>) stack.top(</xsl:text>
    		<xsl:value-of select="count(../vm:parameter) - position()"/>
    		<xsl:text>)</xsl:text>
    	</xsl:for-each>
    	<xsl:text>);</xsl:text>	
    	<xsl:text>
        stack.remove(</xsl:text>
    	<xsl:value-of select="count(vm:signature/vm:parameter)"/>
    	<xsl:text>);</xsl:text>
    		<xsl:text>
        stack.push(op1);</xsl:text>
    </xsl:otherwise>
    </xsl:choose>

</xsl:template>



<!-- putfield -->
<xsl:template match="jvm:putfield">
    <xsl:text>
        op2 = stack.pop();
        op1 = stack.pop();
        if(op2 == XMLVM::NULL_POINTER) {
            op1 = XMLVM::NULL_POINTER;
        }
        else {
            ((</xsl:text>
    <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@class-type"/>
    </xsl:call-template>
    <xsl:text>) op1)-&gt;</xsl:text>
    <xsl:value-of select="@field"/>
    <xsl:text> = new </xsl:text>
    <xsl:call-template name="emitTypeWORef">
        <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text> ( * ( (</xsl:text>
    <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>) op2));
        }</xsl:text>
</xsl:template>


<!-- putstatic -->
<xsl:template match="jvm:putstatic">
    <xsl:text>
        op1 = stack.pop();
        if(op1 == XMLVM::NULL_POINTER) {
            </xsl:text><xsl:call-template name="emitTypeWORef">
        <xsl:with-param name="type" select="@class-type"/>
    </xsl:call-template>
    <xsl:text>::</xsl:text>
    <xsl:value-of select="@field"/>
    <xsl:text> = XMLVM::NULL_POINTER;
        }
        else {
            </xsl:text>
    <xsl:call-template name="emitTypeWORef">
        <xsl:with-param name="type" select="@class-type"/>
    </xsl:call-template>
    <xsl:text>::</xsl:text>
    <xsl:value-of select="@field"/>
    <xsl:text> = new </xsl:text>
    <xsl:call-template name="emitTypeWORef">
        <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text> ( * ( (</xsl:text>
    <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
    <xsl:text>) op1));
        }</xsl:text>
</xsl:template>



<!-- instanceof -->
<xsl:template match="jvm:instanceof">
	<xsl:text>
        op1 = stack.pop();
        if(op1 != XMLVM::NULL_POINTER &amp;&amp; dynamic_cast&lt; </xsl:text >
		
	<xsl:call-template name="emitType">
		<xsl:with-param name="type" select="@type" />
	</xsl:call-template>
	<xsl:text> &gt;(op1.obj_ref)) {
            stack.push(new java::lang::INT(1));
        }
        else {
            stack.push(new java::lang::INT(0));
        }
	</xsl:text>
</xsl:template>



<!-- checkcast -->
<xsl:template match="jvm:checkcast">
	<xsl:text>
        op1 = stack.top(0);
        if(op1 == XMLVM::NULL_POINTER || !dynamic_cast&lt; </xsl:text >

	<xsl:choose>
		<xsl:when test="@type = '[Ljava.lang.String;'">
			<xsl:call-template name="emitType">
				<xsl:with-param name="type" select="'java.lang.String'" />
			</xsl:call-template>
		</xsl:when>
		<xsl:otherwise>
			<xsl:call-template name="emitType">
				<xsl:with-param name="type" select="@type" />
			</xsl:call-template>
		</xsl:otherwise>
	</xsl:choose>
	
	<xsl:text> &gt;(op1.obj_ref)) {
            throw new java::lang::ClassCastException();
        }
	</xsl:text>
</xsl:template>



<!-- anewarray -->
<xsl:template match="jvm:anewarray">
	<xsl:text>
        op1 = stack.pop();
        stack.push(new XMLVM::Array&lt; </xsl:text>
	<xsl:call-template name="emitTypeWORef">
		<xsl:with-param name="type" select="@type" />
	</xsl:call-template>
	<xsl:text> &gt;(*(java::lang::INT_ref)op1));
</xsl:text>
</xsl:template>


<!-- aastore -->
<xsl:template match="jvm:aastore">
	<xsl:text>
        op1 = stack.pop(); // set to
        op2 = stack.pop(); // index
        ((XMLVM::ArrayBase_ref)stack.top(0))->set(*(java::lang::INT_ref)op2, op1);
        stack.remove(1);
</xsl:text>
</xsl:template>


<!-- return -->
<xsl:template match="jvm:return">
	<xsl:text>
        return;</xsl:text>
</xsl:template>



<!-- ============================================================================
	 All templates below are essentially helper functions that are called by
	 various other templates.
	 ============================================================================
-->


<!--
	 emitPrototype
	 =============
	 Writes the prototype of a method. Called from within context of tag
	 <method>.
-->	
<xsl:template name="emitPrototype">
	<xsl:if test="@isStatic = 'true'">
		<xsl:text>static </xsl:text>
	</xsl:if>

	<xsl:choose>
		<xsl:when test="vm:signature/vm:return/@type != 'void'">
			<xsl:text>XMLVM::Object_Ptr&lt; </xsl:text>
		</xsl:when>
	</xsl:choose>
	
	<xsl:call-template name="emitTypeWORef">
		<xsl:with-param name="type" select="vm:signature/vm:return/@type"/>
	</xsl:call-template>

	<xsl:choose>
		<xsl:when test="vm:signature/vm:return/@type != 'void'">
			<xsl:text> &gt; </xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text> </xsl:text>
		</xsl:otherwise>
	</xsl:choose>

	<xsl:call-template name="emitMethodName">
		<xsl:with-param name="name" select="@name"/>
	</xsl:call-template>
	<xsl:text>(</xsl:text>
	<xsl:for-each select="vm:signature/vm:parameter">
		<xsl:if test="position() != 1">
			<xsl:text>, </xsl:text>
		</xsl:if>
		<xsl:text>XMLVM::Object_Ptr&lt; </xsl:text>
		<xsl:call-template name="emitTypeWORef">
		    <xsl:with-param name="type" select="@type"/>
		</xsl:call-template>
		<xsl:text> &gt;</xsl:text>
		<xsl:text> arg</xsl:text>
		<xsl:value-of select="position()"/>
	</xsl:for-each>
	<xsl:text>)</xsl:text>
</xsl:template>



<!--
	 initLocals
	 ==========
	 This function is called from the template for <method>. Its task is
	 to initialize the local variables. This basically means that the
	 actual parameters have to be copied to __locals[i]. If the method
	 is not static, 'this' will be copied to __locals[0]. This function
	 basically only emits code for 'this'. The remaining parameters
	 are copied in the template 'initRemainingLocals' below.
-->
<xsl:template name="initLocals">
	<xsl:choose>		
	    <xsl:when test="@isStatic = 'true'">
		    <xsl:call-template name="initRemainingLocals">
			    <xsl:with-param name="offset" select="1"/>
		    </xsl:call-template>
	    </xsl:when>
	    <xsl:otherwise>
		    <xsl:text>
        locals[0] = (java::lang::Object_ref) this;</xsl:text>
		    <xsl:call-template name="initRemainingLocals">
		    	<xsl:with-param name="offset" select="0"/>
	    	</xsl:call-template>
    	</xsl:otherwise>
	</xsl:choose>
</xsl:template>



<xsl:template name="initRemainingLocals">
	<xsl:param name="offset"/>
	<xsl:for-each select="vm:signature/vm:parameter">
		<xsl:text>
        locals[</xsl:text>
		<xsl:value-of select="position() - $offset"/>
		<xsl:text>] = arg</xsl:text>
		<xsl:value-of select="position()"/>
		<xsl:text>;</xsl:text>
	</xsl:for-each>
</xsl:template>



<!--
	 emitMethodName
	 ==============
	 Called whenever a method name has to be written. If the method happens
	 to be a constructor, this function will generate __init() instead.
	 Input: 'name': the name of the method to write.
-->
<xsl:template name="emitMethodName">
	<xsl:param name="name"/>
	<xsl:choose>
		<xsl:when test="$name = '&lt;init&gt;'">
			<xsl:text>__init</xsl:text>
		</xsl:when>
		<xsl:when test="$name = '&lt;clinit&gt;'">
			<xsl:text>__clinit</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:value-of select="$name"/>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>



<!--
	 emitScopedName
	 ==============
	 Writes a scoped name. This function basically translates a Java-style scoped
	 name (e.g., java.lang.String) to a C++-style scoped name
	 (e.g., java::lang::String).
	 Input: 'string': Java-style scoped name.
-->
<xsl:template name="emitScopedName">
  <xsl:param name="string" />

  <xsl:choose>
    <xsl:when test="contains($string, '.')">
      <xsl:value-of select="substring-before($string, '.')" />
	  <xsl:text>::</xsl:text>
      <xsl:call-template name="emitScopedName">
	<xsl:with-param name="string"
	  select="substring(substring-after($string, '.'), 1)" />
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
	<xsl:when test="contains($string, '[')">
	  <xsl:value-of select="substring-before($string, '[')"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:value-of select="$string" />
	</xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template>



<!--
	 emitType
	 ========
	 Emits a type reference. Basic Java types are mapped to certain C++ types
	 (e.g., int is mapped to XMLVM::INT). Object references are mapped to
	 C++ types of the same name with the suffix '_ref'.
	 Input: 'type': Java type
-->
<xsl:template name="emitType">
	<xsl:param name="type"/>

  <xsl:choose>
    <xsl:when test="contains($type, '[')">
	<xsl:text>XMLVM::Array&lt; </xsl:text>
	<xsl:call-template name="emitScopedName">
		<xsl:with-param name="string" select="$type"/>
	</xsl:call-template>
	<xsl:text> &gt; * </xsl:text>
    </xsl:when>

    <xsl:otherwise>

	<xsl:choose>
		<xsl:when test="$type = 'void'">
			<xsl:text>void</xsl:text>
		</xsl:when>
		<xsl:when test="$type = 'int'">
			<xsl:text>java::lang::INT_ref</xsl:text>
		</xsl:when>
		<xsl:when test="$type = 'boolean'">
			<xsl:text>java::lang::boolean_ref</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:call-template name="emitScopedName">
				<xsl:with-param name="string" select="$type"/>
			</xsl:call-template>
			<xsl:text>_ref</xsl:text>
		</xsl:otherwise>
	</xsl:choose>

     </xsl:otherwise>
   </xsl:choose>

</xsl:template>



<!--
	 emitTypeWORef
	 ========
	 Emits a type reference. Basic Java types are mapped to certain C++ types
	 (e.g., int is mapped to XMLVM::INT). Object references are mapped to
	 C++ types of the same name with the suffix '_ref'.
	 Input: 'type': Java type
-->
<xsl:template name="emitTypeWORef">
  <xsl:param name="type"/>

  <xsl:choose>
	<xsl:when test="contains($type, '[')">
		<xsl:text>XMLVM::Array&lt; </xsl:text>
			<xsl:call-template name="emitScopedName">
				<xsl:with-param name="string" select="$type"/>
			</xsl:call-template>
		<xsl:text> &gt; </xsl:text>
	</xsl:when>

    <xsl:otherwise>

	<xsl:choose>
		<xsl:when test="$type = 'void'">
			<xsl:text>void</xsl:text>
		</xsl:when>
		<xsl:when test="$type = 'int'">
			<xsl:text>java::lang::INT</xsl:text>
		</xsl:when>
		<xsl:when test="$type = 'boolean'">
			<xsl:text>java::lang::boolean</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:call-template name="emitScopedName">
				<xsl:with-param name="string" select="$type"/>
			</xsl:call-template>
		</xsl:otherwise>
	</xsl:choose>

     </xsl:otherwise>
   </xsl:choose>

</xsl:template>



<!-- catch-finally -->
<xsl:template match="jvm:catch-finally">
<xsl:text>
        // begin catch-finally
</xsl:text>
	<xsl:apply-templates />
	<xsl:text>
        // end catch-finally
</xsl:text>
</xsl:template>



<!-- jsr -->
<xsl:template match="jvm:jsr">
	<xsl:apply-templates />
	<!-- TODO perhaps problematic because of namespaces. -->
	<xsl:if test="contains(parent::node(), 'catch')">
		<xsl:text>
        goto label998; // jsr
</xsl:text>
	</xsl:if>
</xsl:template>


<!--
	 Default template. If the XMLVM file should contain an instruction
	 that is not handled by this stylesheet, this default template
	 will make sure we notice it by writing a special error function
	 to the output stream.
-->
<xsl:template match="*">
	<xsl:text>
        ERROR(); // </xsl:text>
	<xsl:value-of select="name()"/>
</xsl:template>


</xsl:stylesheet>
