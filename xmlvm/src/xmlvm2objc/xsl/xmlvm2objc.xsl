<?xml version="1.0"?>


<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xs = "http://www.w3.org/2001/XMLSchema"
                xmlns:vm ="http://xmlvm.org"
                xmlns:jvm="http://xmlvm.org/jvm"
                xmlns:dex="http://xmlvm.org/dex"
                version="2.0">

<xsl:param name="pass">emitHeader</xsl:param>
<xsl:param name="header">default.h</xsl:param>

<xsl:output method="text" indent="no"/>

<xsl:template match="vm:xmlvm">
  <xsl:text>
// Automatically generated by xmlvm2obj. Do not edit!

</xsl:text>  




  <xsl:choose>
    <xsl:when test="$pass = 'emitHeader'">
      <xsl:text>
	</xsl:text>
      <xsl:call-template name="emitInterfaces"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>
#import "</xsl:text>
      <xsl:value-of select="$header"/>
      <xsl:text>"

</xsl:text>
      <xsl:call-template name="emitImplementation"/>
      
      <xsl:if test="vm:class/vm:method/@name = 'main'">
        <xsl:call-template name="emitMainMethod"/>
      </xsl:if>
      
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>



<xsl:template name="emitMainMethod">
  <xsl:text>
  
      
int main(int argc, char* argv[])
{
    [</xsl:text>
    <xsl:variable name="cl" as="node()" select="vm:class/vm:method[@name = 'main']/.."/>
    <xsl:value-of select="vm:fixname($cl/@package)"/>
    <xsl:text>_</xsl:text>
    <xsl:value-of select="$cl/@name"/>
    <xsl:text> main___java_lang_String_ARRAYTYPE: nil];
	return 0;						 
}
  
  
</xsl:text>
</xsl:template>



<xsl:template name="emitInterfaces">
  <xsl:for-each select="vm:class">
    <xsl:variable name="cclname" select="concat(@package, '.', @name)"/>
    <xsl:variable name="clname" select="vm:fixname($cclname)"/>
  
    <xsl:text>
</xsl:text>
    <xsl:value-of select="if (@isInterface = 'true') then '@protocol ' else '@interface '"/>
    <xsl:value-of select="vm:fixname(@package)"/>
    <xsl:text>_</xsl:text>
    <xsl:value-of select="vm:fixname(@name)"/>
    <xsl:if test="not(@isInterface = 'true')">
      <xsl:text> : </xsl:text>
      <xsl:value-of select="vm:fixname(@extends)"/>
    </xsl:if>
    <xsl:if test="@interfaces">
      <xsl:text> &lt;</xsl:text>
      <xsl:value-of select="vm:fixname(@interfaces)"/>
      <xsl:text>&gt;</xsl:text>
    </xsl:if>
    <xsl:text>
</xsl:text>
    <xsl:if test="not(@isInterface = 'true')">
      <xsl:text>{
</xsl:text>
      <!-- Emit declarations for all non-static fields -->
      <xsl:for-each select="vm:field[not(@isStatic = 'true')]">
        <xsl:text>@private </xsl:text>
        <xsl:call-template name="emitType">
          <xsl:with-param name="type" select="@type"/>
        </xsl:call-template>
        <xsl:text> </xsl:text>
        <xsl:value-of select="vm:fixname(../@package)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(../@name)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(@name)"/>
        <xsl:text>;
</xsl:text>
      </xsl:for-each>
      <xsl:text>
}
</xsl:text>
    </xsl:if>
    <!-- Emit default constructor and initializer used for initializing member variables -->
    <xsl:text>+ (void) initialize;
- (id) init;
</xsl:text>
    <!-- Emit declarations for getter and setter methods for all fields -->
    <xsl:for-each select="vm:field">
      <!-- Emit getter -->
      <xsl:value-of select="if (@isStatic = 'true') then '+' else '-'"/>
      <xsl:text> (</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text>) _GET_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>;
</xsl:text>
      <!-- Emit setter -->
      <xsl:value-of select="if (@isStatic = 'true') then '+' else '-'"/>
      <xsl:text> (void) _PUT_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>: (</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text>) v</xsl:text>
      <xsl:text>;
</xsl:text>
    </xsl:for-each>
    <!-- Emit declarations for all methods -->
    <xsl:for-each select="vm:method">
      <xsl:if test="not(vm:isDuplicateMethod(.))">
        <xsl:call-template name="emitMethodSignature"/>
        <xsl:text>;
</xsl:text>
      </xsl:if>
    </xsl:for-each>
      
    <!-- Check if there is a method equals(Object) -->
    <xsl:if test="vm:method[@name = 'equals']">
      <xsl:text>- (BOOL) isEqual:(id)o;
</xsl:text>
    </xsl:if>
    <xsl:text>
@end

</xsl:text>
	<!-- For Java interfaces we also emit an Objective-C @interface. The reason is that
	in Java it is possible to obtain an interface type via getClass(). However, in Objective-C
	@protocols are not first-class-types and we cannot send a @protocol the 'class' method.
	Thankfully Objective-C does not object to having the same identifier used both for
	@interface and @protocol. -->
	<xsl:if test="@isInterface = 'true'">
	  <xsl:text>@interface </xsl:text>
	  <xsl:value-of select="$clname"/>
	  <xsl:text> : java_lang_Object &lt;</xsl:text>
	  <xsl:value-of select="$clname"/>
	  <xsl:text>&gt;
@end
</xsl:text>
	</xsl:if>
  </xsl:for-each>
  
</xsl:template>


<xsl:template name="emitImplementation">
  <xsl:for-each select="vm:class[@isInterface = 'true']">
    <xsl:variable name="cclname" select="concat(@package, '.', @name)"/>
    <xsl:variable name="clname" select="vm:fixname($cclname)"/>
	  <xsl:text>@implementation </xsl:text>
	  <xsl:value-of select="$clname"/>
	  <xsl:text>
@end
</xsl:text>
  </xsl:for-each>
  <xsl:for-each select="vm:class[not(@isInterface = 'true')]">
    <!-- Emit global variable definition for all static fields -->
    <xsl:for-each select="vm:field[@isStatic = 'true']">
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text> _STATIC_</xsl:text>
      <xsl:value-of select="vm:fixname(../@package)"/>
      <xsl:text>_</xsl:text>
      <xsl:value-of select="vm:fixname(../@name)"/>
      <xsl:text>_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:if test="@value">
        <xsl:text> = </xsl:text>
        <!-- TODO String values need to be surrounded by quotes and escaped properly. -->
        <xsl:if test="@type = 'java.lang.String'">
          <xsl:text>@</xsl:text>
        </xsl:if>
        <xsl:value-of select="@value"/>
      </xsl:if>
      <xsl:text>;
</xsl:text>
    </xsl:for-each>

    <xsl:text>
@implementation </xsl:text>
    <xsl:value-of select="vm:fixname(@package)"/>
    <xsl:text>_</xsl:text>
    <xsl:value-of select="vm:fixname(@name)"/>
    <xsl:text>;

</xsl:text>

    <!-- Emit default Objective-C class initialized used for member initialization -->
    <xsl:text>+ (void) initialize
{
    if (strcmp(class_getName(self), "</xsl:text>
    	<xsl:value-of select="vm:fixname(@package)"/>
    	<xsl:text>_</xsl:text>
    	<xsl:value-of select="vm:fixname(@name)"/>
    	<xsl:text>") == 0) {</xsl:text>
        <xsl:for-each select="vm:field[@isStatic = 'true' and vm:isObjectRef(@type)]">
          <xsl:text>
        _STATIC_</xsl:text>
          <xsl:value-of select="vm:fixname(../@package)"/>
          <xsl:text>_</xsl:text>
          <xsl:value-of select="vm:fixname(../@name)"/>
          <xsl:text>_</xsl:text>
          <xsl:value-of select="vm:fixname(@name)"/>
          <xsl:text> = (id) [NSNull null];</xsl:text>
        </xsl:for-each>
    	<!-- If there is a Java class initializer, call it. -->
        <xsl:if test="vm:method[@name = '&lt;clinit&gt;']">
          <xsl:text>
        [</xsl:text>
          <xsl:value-of select="vm:fixname(@package)"/>
          <xsl:text>_</xsl:text>
          <xsl:value-of select="vm:fixname(@name)"/>
          <xsl:text> __clinit_</xsl:text>
          <xsl:value-of select="vm:fixname(@package)"/>
          <xsl:text>_</xsl:text>
          <xsl:value-of select="vm:fixname(@name)"/>
          <xsl:text>];</xsl:text>
        </xsl:if>
      <xsl:text>
    }</xsl:text>
    <xsl:text>
}

</xsl:text>
    
    <!-- Emit default Objective-C constructor used for member initialization -->
    <xsl:text>- (id) init
{
    if (self = [super init]) {
</xsl:text>
      <!-- Emit declarations for all non-static member fields -->
      <xsl:for-each select="vm:field[not(@isStatic = 'true') and vm:isObjectRef(@type)]">
        <xsl:text>        </xsl:text>
        <xsl:value-of select="vm:fixname(../@package)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(../@name)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(@name)"/>
        <xsl:text> = (id) [NSNull null];
</xsl:text>
      </xsl:for-each>
    <xsl:text>    }
    return self;
}

</xsl:text>

    <!-- Emit destructor -->
    <xsl:text>- (void) dealloc
{
</xsl:text>
<xsl:if test="vm:method[@name='finalize' and 
                        not(vm:signature/vm:parameter) and 
                        vm:signature/vm:return[@type='void']]">
    <xsl:text>    [self finalize_</xsl:text><xsl:value-of select="vm:fixname(concat(@package, '.', @name))"/><xsl:text>__];
</xsl:text>
</xsl:if>
	<xsl:for-each select="vm:field[not(@isStatic = 'true') and vm:isObjectRef(@type)]">
	  <xsl:text>    [</xsl:text>
      <xsl:value-of select="vm:fixname(../@package)"/>
      <xsl:text>_</xsl:text>
      <xsl:value-of select="vm:fixname(../@name)"/>
      <xsl:text>_</xsl:text>
	  <xsl:value-of select="vm:fixname(@name)"/>
	  <xsl:text> release];
</xsl:text>
	</xsl:for-each>
	<xsl:text>    [super dealloc];
}

</xsl:text>

	<!-- Emit getters and setters for all fields -->
    <xsl:for-each select="vm:field">
      <!-- Emit getter -->
      <xsl:variable name="field">
        <xsl:value-of select="vm:fixname(../@package)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(../@name)"/>
        <xsl:text>_</xsl:text>
        <xsl:value-of select="vm:fixname(@name)"/>
      </xsl:variable>
      <xsl:value-of select="if (@isStatic = 'true') then '+' else '-'"/>
      <xsl:text> (</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text>) _GET_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>
{
    return </xsl:text>
      <xsl:if test="vm:isObjectRef(@type)">
        <xsl:text>[[</xsl:text>
      </xsl:if>
      <xsl:value-of select="if (@isStatic = 'true') then '_STATIC_' else ''"/>
      <xsl:value-of select="$field"/>
      <!-- For object references we need to do the retain and autorelease. It is possible
           that the object reference returned by this getter is only kept in a local
           variable (which, in contrast to an instance variable, is not retained). If
           this member is then over-written later, it might be possible that the
           reference held by the local variable become invalid. -->
      <xsl:if test="vm:isObjectRef(@type)">
        <xsl:text> retain] autorelease]</xsl:text>
      </xsl:if>
      <xsl:text>;
}

</xsl:text>
      <!-- Emit setter -->
      <xsl:value-of select="if (@isStatic = 'true') then '+' else '-'"/>
      <xsl:text> (void) _PUT_</xsl:text>
      <xsl:value-of select="vm:fixname(@name)"/>
      <xsl:text>: (</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text>) v
{
    </xsl:text>
    <xsl:if test="vm:isObjectRef(@type)">
        <xsl:text>[v retain];
    [</xsl:text>
        <xsl:value-of select="if (@isStatic = 'true') then '_STATIC_' else ''"/>
        <xsl:value-of select="$field"/>
        <xsl:text> release];
    </xsl:text>
    </xsl:if>
      <xsl:value-of select="if (@isStatic = 'true') then '_STATIC_' else ''"/>
      <xsl:value-of select="$field"/>
      <xsl:text> = v;
}

</xsl:text>
    </xsl:for-each>
    
    <xsl:for-each select="vm:method">
      <xsl:if test="not(vm:isDuplicateMethod(.))">
        <xsl:call-template name="emitMethodSignature"/>
        <xsl:text>
</xsl:text>
        <xsl:choose>
          <xsl:when test="../.[@isInterface = 'true'] or @isAbstract = 'true'">
          <xsl:text>{
}

</xsl:text>
          </xsl:when>
          <xsl:when test="@isNative = 'true'">
            <xsl:text>{
    NSException* ex = [[NSException alloc] initWithName:@"Native method not implemented" reason:nil userInfo:nil];
    @throw ex;
}

</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:apply-templates/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
    </xsl:for-each>

    <!-- Check if there is a method equals(Object) -->
    <xsl:if test="vm:method[@name = 'equals']">
      <xsl:text>- (BOOL) isEqual:(id)o
{
	return [self equals___java_lang_Object:o];
}
</xsl:text>
    </xsl:if>
      
    <xsl:text>
@end

</xsl:text>
  </xsl:for-each>
  
</xsl:template>


<xsl:template match="vm:signature">
  <!-- Do nothing -->
</xsl:template>


<xsl:template match="jvm:code">
<xsl:text>{
    XMLVMElem _stack[</xsl:text>
  <xsl:value-of select="../@stack"/>
  <xsl:text>];
    XMLVMElem _locals[</xsl:text>
  <xsl:value-of select="../@locals"/>
  <xsl:text>];
    int _sp = 0;
    XMLVMElem _op1, _op2, _op3;
</xsl:text>
  <xsl:if test="vm:useAutoReleasePool(.)">
    <xsl:text>    NSAutoreleasePool* _pool = [[NSAutoreleasePool alloc] init];
</xsl:text>
  </xsl:if>
  <xsl:call-template name="initLocals"/>
  <xsl:apply-templates/>
  <xsl:text>}


</xsl:text>
</xsl:template>


<xsl:template match="jvm:var">
  <!-- Do nothing -->
</xsl:template>


<xsl:template match="jvm:label">
  <xsl:text>    label</xsl:text>
  <xsl:value-of select="@id"/>
  <xsl:text>:;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:catch">
  <xsl:text>    @try {
</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>    } @catch (</xsl:text>
    <xsl:value-of select="vm:fixname(@type)"/>
    <xsl:text>* _ex) {
        _stack[_sp++].o = _ex;
        goto label</xsl:text>
    <xsl:value-of select="@using"/>
    <xsl:text>;
    }
</xsl:text>
</xsl:template>


<xsl:template match="jvm:athrow">
  <xsl:text>    _op1.o = _stack[--_sp].o;
    @throw _op1.o;
</xsl:text>
</xsl:template>

    
<xsl:template match="jvm:aload">
  <xsl:text>    _stack[_sp++].o = _locals[</xsl:text>
  <xsl:value-of select="@index"/>
  <xsl:text>].o;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:astore">
  <xsl:text>    _op1.o = _stack[--_sp].o;
    _locals[</xsl:text>
  <xsl:value-of select="@index"/>
  <xsl:text>].o = _op1.o;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:return">
  <xsl:if test="vm:useAutoReleasePool(.)">
    <xsl:text>    [_pool release];
</xsl:text>
  </xsl:if>
  <xsl:text>    return;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:ireturn">
  <xsl:text>    _op1.i = _stack[--_sp].i;
</xsl:text>
  <xsl:if test="vm:useAutoReleasePool(.)">
    <xsl:text>    [_pool release];
</xsl:text>
  </xsl:if>
  <xsl:text>    return _op1.i;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:lreturn">
  <xsl:text>    _op1.l = _stack[--_sp].l;
</xsl:text>
  <xsl:if test="vm:useAutoReleasePool(.)">
    <xsl:text>    [_pool release];
</xsl:text>
  </xsl:if>
  <xsl:text>    return _op1.l;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:freturn">
  <xsl:text>    _op1.f = _stack[--_sp].f;
</xsl:text>
  <xsl:if test="vm:useAutoReleasePool(.)">
    <xsl:text>    [_pool release];
</xsl:text>
  </xsl:if>
  <xsl:text>    return _op1.f;
</xsl:text>
</xsl:template>

<xsl:template match="jvm:dreturn">
  <xsl:text>    _op1.d = _stack[--_sp].d;
</xsl:text>
  <xsl:if test="vm:useAutoReleasePool(.)">
    <xsl:text>    [_pool release];
</xsl:text>
  </xsl:if>
  <xsl:text>    return _op1.d;
</xsl:text>
</xsl:template>

<xsl:template match="jvm:areturn">
  <xsl:text>    _op1.o = _stack[--_sp].o;
    [_op1.o retain];
</xsl:text>
  <xsl:if test="vm:useAutoReleasePool(.)">
    <xsl:text>    [_pool release];
</xsl:text>
  </xsl:if>
  <xsl:text>    return _op1.o;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:ldc|jvm:ldc_w|jvm:ldc2_w">
  <xsl:text>    _stack[_sp++]</xsl:text>
  <xsl:choose>
    <xsl:when test="@type = 'float'">
      <xsl:text>.f = </xsl:text>
      <xsl:value-of select="@value"/>
    </xsl:when>
    <xsl:when test="@type = 'double'">
      <xsl:text>.d = </xsl:text>
      <xsl:value-of select="@value"/>
    </xsl:when>
    <xsl:when test="@type = 'int'">
      <xsl:text>.i = </xsl:text>
      <xsl:value-of select="@value"/>
    </xsl:when>
    <xsl:when test="@type = 'long'">
      <xsl:text>.l = </xsl:text>
      <xsl:value-of select="@value"/>
    </xsl:when>
    <xsl:when test="@type = 'java.lang.String'">
      <xsl:text>.o = @"</xsl:text>
      <xsl:value-of select="@value"/>
      <xsl:text>"</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>.o = [</xsl:text>
      <xsl:value-of select="vm:fixname(@type)"/>
      <xsl:text> getClass__]</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:getstatic">
  <xsl:variable name="typedAccess">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    _op1</xsl:text>
  <xsl:value-of select="$typedAccess"/>
  <xsl:text> = [</xsl:text>
  <xsl:value-of select="vm:fixname(@class-type)"/>
  <xsl:text> _GET_</xsl:text>
  <xsl:value-of select="vm:fixname(@field)"/>
  <xsl:text>];
    _stack[_sp++]</xsl:text>
  <xsl:value-of select="$typedAccess"/>
  <xsl:text> = _op1</xsl:text>
  <xsl:value-of select="$typedAccess"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:putstatic">
  <xsl:variable name="typedAccess">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    _op1</xsl:text>
  <xsl:value-of select="$typedAccess"/>
  <xsl:text> = _stack[--_sp]</xsl:text>
  <xsl:value-of select="$typedAccess"/>
  <xsl:text>;
    [</xsl:text>
  <xsl:value-of select="vm:fixname(@class-type)"/>
  <xsl:text> _PUT_</xsl:text>
  <xsl:value-of select="vm:fixname(@field)"/>
  <xsl:text>: _op1</xsl:text>
  <xsl:value-of select="$typedAccess"/>
  <xsl:text>];
</xsl:text>
</xsl:template>


<xsl:template match="jvm:aconst_null">
  <xsl:text>    _stack[_sp++].o = [NSNull null];
</xsl:text>
</xsl:template>


<xsl:template match="jvm:iconst">
  <xsl:text>    _stack[_sp++].i = </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:lconst">
  <xsl:text>    _stack[_sp++].l = </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:fconst">
  <xsl:text>    _stack[_sp++].f = </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:dconst">
  <xsl:text>    _stack[_sp++].d = </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:istore">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _locals[</xsl:text>
  <xsl:value-of select="@index"/>
  <xsl:text>].i = _op1.i;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:dstore">
  <xsl:text>    _op1.d = _stack[--_sp].d;
    _locals[</xsl:text>
  <xsl:value-of select="@index"/>
  <xsl:text>].d = _op1.d;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:fstore">
  <xsl:text>    _op1.f = _stack[--_sp].f;
    _locals[</xsl:text>
  <xsl:value-of select="@index"/>
  <xsl:text>].f = _op1.f;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:fneg">
  <xsl:text>    _op1.f = _stack[--_sp].f;
    _stack[_sp++].f = -_op1.f;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:dneg">
  <xsl:text>    _op1.d = _stack[--_sp].d;
    _stack[_sp++].d = -_op1.d;
</xsl:text>
</xsl:template>

<xsl:template match="jvm:ineg">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _stack[_sp++].i = -_op1.i;
</xsl:text>
</xsl:template>

<xsl:template match="jvm:iload">
  <xsl:text>    _op1.i = _locals[</xsl:text>
  <xsl:value-of select="@index"/>
  <xsl:text>].i;
    _stack[_sp++].i = _op1.i;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:lload">
  <xsl:text>    _op1.l = _locals[</xsl:text>
  <xsl:value-of select="@index"/>
  <xsl:text>].l;
  _stack[_sp++].l = _op1.l;
</xsl:text>
</xsl:template>


  <xsl:template match="jvm:dload">
  <xsl:text>    _op1.d = _locals[</xsl:text>
  <xsl:value-of select="@index"/>
  <xsl:text>].d;
    _stack[_sp++].d = _op1.d;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:fload">
  <xsl:text>    _op1.f = _locals[</xsl:text>
  <xsl:value-of select="@index"/>
  <xsl:text>].f;
    _stack[_sp++].f = _op1.f;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:iinc">
  <xsl:text>    _locals[</xsl:text>
  <xsl:value-of select="@index"/>
  <xsl:text>].i += </xsl:text>
  <xsl:value-of select="@incr"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:iand">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    _stack[_sp++].i = _op1.i &amp; _op2.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:land">
  <xsl:text>    _op2.l = _stack[--_sp].l;
    _op1.l = _stack[--_sp].l;
    _stack[_sp++].l = _op1.l &amp; _op2.l;</xsl:text>
</xsl:template>

<xsl:template match="jvm:ior">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    _stack[_sp++].i = _op1.i | _op2.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:ixor">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    _stack[_sp++].i = _op1.i ^ _op2.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:iadd">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    _stack[_sp++].i = _op1.i + _op2.i;</xsl:text>
</xsl:template>


<xsl:template match="jvm:fadd">
  <xsl:text>    _op2.f = _stack[--_sp].f;
    _op1.f = _stack[--_sp].f;
    _stack[_sp++].f = _op1.f + _op2.f;</xsl:text>
</xsl:template>


<xsl:template match="jvm:dadd">
  <xsl:text>    _op2.d = _stack[--_sp].d;
    _op1.d = _stack[--_sp].d;
    _stack[_sp++].d = _op1.d + _op2.d;</xsl:text>
</xsl:template>


<xsl:template match="jvm:isub">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    _stack[_sp++].i = _op1.i - _op2.i;</xsl:text>
</xsl:template>


<xsl:template match="jvm:fsub">
  <xsl:text>    _op2.f = _stack[--_sp].f;
    _op1.f = _stack[--_sp].f;
    _stack[_sp++].f = _op1.f - _op2.f;</xsl:text>
</xsl:template>


<xsl:template match="jvm:imul">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    _stack[_sp++].i = _op1.i * _op2.i;</xsl:text>
</xsl:template>


<xsl:template match="jvm:fmul">
  <xsl:text>    _op2.f = _stack[--_sp].f;
    _op1.f = _stack[--_sp].f;
    _stack[_sp++].f = _op1.f * _op2.f;</xsl:text>
</xsl:template>


<xsl:template match="jvm:dmul">
  <xsl:text>    _op2.d = _stack[--_sp].d;
    _op1.d = _stack[--_sp].d;
    _stack[_sp++].d = _op1.d * _op2.d;</xsl:text>
</xsl:template>


<xsl:template match="jvm:idiv">
  <xsl:text>    _op2.i = _stack[--_sp].i;
  _op1.i = _stack[--_sp].i;
  _stack[_sp++].i = _op1.i / _op2.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:fdiv">
  <xsl:text>    _op2.f = _stack[--_sp].f;
  _op1.f = _stack[--_sp].f;
  _stack[_sp++].f = _op1.f / _op2.f;</xsl:text>
</xsl:template>

<xsl:template match="jvm:ddiv">
  <xsl:text>    _op2.d = _stack[--_sp].d;
    _op1.d = _stack[--_sp].d;
    _stack[_sp++].d = _op1.d / _op2.d;</xsl:text>
</xsl:template>


<xsl:template match="jvm:d2i">
  <xsl:text>    _op1.d = _stack[--_sp].d;
    _stack[_sp++].i = (int) _op1.d;</xsl:text>
</xsl:template>

<xsl:template match="jvm:irem">
  <xsl:text>    
  _op2.i = _stack[--_sp].i; // Integer remainder of 
  _op1.i = _stack[--_sp].i;
  _stack[_sp++].i = _op1.i % _op2.i;</xsl:text>
</xsl:template>



  <xsl:template match="jvm:f2i">
  <xsl:text>    _op1.f = _stack[--_sp].f;
  _stack[_sp++].i = (int) _op1.f;</xsl:text>
</xsl:template>

  <xsl:template match="jvm:d2f">
  <xsl:text>    _op1.d = _stack[--_sp].d;
    _stack[_sp++].f = (float) _op1.d;</xsl:text>
</xsl:template>


<xsl:template match="jvm:f2d">
  <xsl:text>    _op1.f = _stack[--_sp].f;
    _stack[_sp++].d = (double) _op1.f;</xsl:text>
</xsl:template>


<xsl:template match="jvm:i2f">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _stack[_sp++].f = (float) _op1.i;</xsl:text>
</xsl:template>
  
<xsl:template match="jvm:i2b">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _op1.i = (int) (_op1.i &amp; 0xFF);
    _stack[_sp++].i = (_op1.i &amp; 0x80) ? _op1.i | 0xffffff00 : _op1.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:i2s">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _op1.i = (int) (_op1.i &amp; 0xffff);
    _stack[_sp++].i = (_op1.i &amp; 0x8000) ? _op1.i | 0xffff0000 : _op1.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:i2l">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _stack[_sp++].l = (long) _op1.i;</xsl:text>
</xsl:template>
  
<xsl:template match="jvm:l2f">
  <xsl:text>    _op1.l = _stack[--_sp].l;
  _stack[_sp++].f = (float) _op1.l;</xsl:text>
</xsl:template>


<xsl:template match="jvm:i2d">
  <xsl:text>    _op1.i = _stack[--_sp].i;
  _stack[_sp++].d = (double) _op1.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:putfield">
  <xsl:variable name="m">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    _op1</xsl:text>
  <xsl:value-of select="$m"/>
  <xsl:text> = _stack[--_sp]</xsl:text>
  <xsl:value-of select="$m"/>
  <xsl:text>;
    </xsl:text>
  <xsl:text>_op2.o = _stack[--_sp].o;
    </xsl:text>
  <xsl:text>[((</xsl:text>
  <xsl:call-template name="emitType">
    <xsl:with-param name="type" select="@class-type"/>
  </xsl:call-template>
  <xsl:text>) _op2.o) _PUT_</xsl:text>
  <xsl:value-of select="vm:fixname(@field)"/>
  <xsl:text>: _op1</xsl:text>
  <xsl:value-of select="$m"/>
  <xsl:text>];
</xsl:text>
</xsl:template>



<xsl:template match="jvm:getfield">
  <xsl:variable name="m">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    _op1.o = _stack[--_sp].o;
    _op2</xsl:text>
  <xsl:value-of select="$m"/>
  <xsl:text> = [((</xsl:text>
  <xsl:call-template name="emitType">
    <xsl:with-param name="type" select="@class-type"/>
  </xsl:call-template>
  <xsl:text>) _op1.o) </xsl:text>
  <xsl:text> _GET_</xsl:text>
  <xsl:value-of select="vm:fixname(@field)"/>
  <xsl:text>];
    _stack[_sp++]</xsl:text>
  <xsl:value-of select="$m"/>
  <xsl:text> = _op2</xsl:text>
  <xsl:value-of select="$m"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:pop">
  <xsl:text>    _sp--;
</xsl:text>
</xsl:template>

<xsl:template match="jvm:dup">
  <xsl:text>    _op1 = _stack[_sp - 1];
    _stack[_sp++] = _op1;
</xsl:text>
</xsl:template>


<!-- dup_x1 -->
<xsl:template match="jvm:dup_x1">
  <xsl:text>    _op1 = _stack[--_sp];
    _op2 = _stack[--_sp];
    _stack[_sp++] = _op1;
    _stack[_sp++] = _op2;
    _stack[_sp++] = _op1;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:new">
    <xsl:text>    _stack[_sp++].o = [[[</xsl:text>
    <xsl:value-of select="vm:fixname(@type)"/>
    <xsl:text> alloc] init] autorelease];
</xsl:text>
</xsl:template>


<xsl:template match="jvm:goto">
  <xsl:text>    goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:lookupswitch">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    switch (_op1.i) {</xsl:text>
  <xsl:for-each select="jvm:case">
    <xsl:text>
        case </xsl:text>
    <xsl:value-of select="@key"/>
    <xsl:text>: goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;</xsl:text>
  </xsl:for-each>
  <xsl:if test="jvm:default">
    <xsl:text>
        default: goto label</xsl:text>
    <xsl:value-of select="jvm:default/@label"/>
    <xsl:text>;</xsl:text>
  </xsl:if>
  <xsl:text>
    }
</xsl:text>
</xsl:template>


<xsl:template match="jvm:bipush|jvm:sipush">
  <xsl:text>    _stack[_sp++].i = </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:ifeq">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    if (_op1.i == 0) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:ifne">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    if (_op1.i != 0) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:iflt">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    if (_op1.i &lt; 0) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:ifle">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    if (_op1.i &lt;= 0) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:ifgt">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    if (_op1.i &gt; 0) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:ifge">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    if (_op1.i &gt;= 0) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:ifnull">
  <xsl:text>    _op1.o = _stack[--_sp].o;
    if (_op1.o == [NSNull null]) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:ifnonnull">
  <xsl:text>    _op1.o = _stack[--_sp].o;
    if (_op1.o != [NSNull null]) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:if_icmplt">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    if (_op1.i &lt; _op2.i) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:if_icmpge">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    if (_op1.i &gt;= _op2.i) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:if_icmple">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    if (_op1.i &lt;= _op2.i) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:if_icmpne">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    if (_op1.i != _op2.i) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:if_icmpeq">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    if (_op1.i == _op2.i) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:if_acmpne">
  <xsl:text>    _op2.o = _stack[--_sp].o;
    _op1.o = _stack[--_sp].o;
    if (_op1.o != _op2.o) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:if_acmpeq">
  <xsl:text>    _op2.o = _stack[--_sp].o;
    _op1.o = _stack[--_sp].o;
    if (_op1.o == _op2.o) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:tableswitch">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    switch(_op1.i) {
    </xsl:text>
  <xsl:for-each select="jvm:case">
    <xsl:text>case </xsl:text>
    <xsl:value-of select="../@min + position() - 1"/>
    <xsl:text>: goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;
    </xsl:text>
  </xsl:for-each>
  <xsl:text>default: goto label</xsl:text>
  <xsl:value-of select="jvm:default/@label"/>
  <xsl:text>;
    }
</xsl:text>
</xsl:template>


<xsl:template match="jvm:dcmpg">
  <xsl:text>    _op2.f = (float) _stack[--_sp].d;
    _op1.f = (float) _stack[--_sp].d;
    _op3.i = 1;
    if (_op1.f &gt; _op2.f)
      _op3.i = 1;
    else if (_op1.f == _op2.f)
      _op3.i = 0;
    else if (_op1.f &lt; _op2.f)
      _op3.i = -1;
    _stack[_sp++].i = _op3.i;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:fcmpg">
  <xsl:text>    _op2.f = _stack[--_sp].f;
    _op1.f = _stack[--_sp].f;
    _op3.i = 1;
    if (_op1.f &gt; _op2.f)
      _op3.i = 1;
    else if (_op1.f == _op2.f)
      _op3.i = 0;
    else if (_op1.f &lt; _op2.f)
      _op3.i = -1;
    _stack[_sp++].i = _op3.i;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:fcmpl">
  <xsl:text>    _op2.f = _stack[--_sp].f;
    _op1.f = _stack[--_sp].f;
    _op3.i = -1;
    if (_op1.f &gt; _op2.f)
      _op3.i = 1;
    else if (_op1.f == _op2.f)
      _op3.i = 0;
    else if (_op1.f &lt; _op2.f)
      _op3.i = -1;
    _stack[_sp++].i = _op3.i;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:invokestatic">
  <xsl:text>    _sp -= </xsl:text>
  <xsl:value-of select="count(vm:signature/vm:parameter)"/>
  <xsl:text>;
    </xsl:text>
  <xsl:variable name="returnTypedAccess">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="vm:signature/vm:return/@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:if test="vm:signature/vm:return/@type != 'void'">
    <xsl:text>_op1</xsl:text>
    <xsl:value-of select="$returnTypedAccess"/>
    <xsl:text> = </xsl:text>
  </xsl:if>
  <xsl:text>[</xsl:text>
  <xsl:value-of select="vm:fixname(@class-type)"/>
  <xsl:text> </xsl:text>
  <xsl:value-of select="@method"/>
  <xsl:call-template name="appendSignature"/>
  <xsl:for-each select="vm:signature/vm:parameter">
    <xsl:text>:_stack[_sp + </xsl:text>
    <xsl:value-of select="position() - 1"/>
    <xsl:text>]</xsl:text>
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
  </xsl:for-each>
  <xsl:text>];
</xsl:text>
  <xsl:if test="vm:signature/vm:return/@type != 'void'">
    <xsl:if test="vm:isObjectRef(vm:signature/vm:return/@type)">
      <xsl:text>    [_op1.o autorelease];
</xsl:text>
    </xsl:if>
    <xsl:text>    _stack[_sp++]</xsl:text>
    <xsl:value-of select="$returnTypedAccess"/>
    <xsl:text> = _op1</xsl:text>
    <xsl:value-of select="$returnTypedAccess"/>
    <xsl:text>;
</xsl:text>
  </xsl:if>
</xsl:template>



<xsl:template match="jvm:invokevirtual|jvm:invokeinterface|jvm:invokespecial">
  <xsl:text>    _sp -= </xsl:text>
  <xsl:value-of select="count(vm:signature/vm:parameter) + 1"/>
  <xsl:text>;
    </xsl:text>
  <xsl:variable name="returnTypedAccess">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="vm:signature/vm:return/@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:if test="vm:signature/vm:return/@type != 'void'">
    <xsl:text>_op1</xsl:text>
    <xsl:value-of select="$returnTypedAccess"/>
    <xsl:text> = </xsl:text>
  </xsl:if>
  <xsl:text>[((</xsl:text>
  
  <xsl:variable name="baseClass">
    <!-- TODO what if this invoke instruction is nested within a catch-block? -->
    <xsl:value-of select="../../../@extends"/>
  </xsl:variable>
  <xsl:choose>
 	<xsl:when test="name() = 'jvm:invokevirtual' or compare(@class-type,$baseClass) != 0">
		  <xsl:call-template name="emitType">
		    <xsl:with-param name="type" select="@class-type"/>
  			</xsl:call-template>
  		<xsl:text>) _stack[_sp].o) </xsl:text>
  	</xsl:when>
    <xsl:otherwise>
	  <xsl:text>super)) </xsl:text>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:call-template name="emitMethodName">
    <xsl:with-param name="name" select="@method"/>
    <xsl:with-param name="class-type" select="@class-type"/>
  </xsl:call-template>
  <xsl:call-template name="appendSignature"/>
  <xsl:for-each select="vm:signature/vm:parameter">
    <xsl:text>:_stack[_sp + </xsl:text>
    <xsl:value-of select="position()"/>
    <xsl:text>]</xsl:text>
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
  </xsl:for-each>
  <xsl:text>];
</xsl:text>
  <xsl:if test="vm:signature/vm:return/@type != 'void'">
    <xsl:if test="vm:isObjectRef(vm:signature/vm:return/@type)">
      <xsl:text>    [_op1.o autorelease];
</xsl:text>
    </xsl:if>
    <xsl:text>    _stack[_sp++]</xsl:text>
    <xsl:value-of select="$returnTypedAccess"/>
    <xsl:text> = _op1</xsl:text>
    <xsl:value-of select="$returnTypedAccess"/>
    <xsl:text>;
</xsl:text>
  </xsl:if>
</xsl:template>

<xsl:template match="jvm:newarray">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _stack[_sp++].o = [XMLVMArray createSingleDimensionWithType:</xsl:text>
  <xsl:value-of select="vm:typeID(@base-type)"/>
  <xsl:text> andSize:_op1.i];
</xsl:text>
</xsl:template>

<xsl:template match="jvm:anewarray">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _stack[_sp++].o = [XMLVMArray createSingleDimensionWithType:0 andSize:_op1.i];
</xsl:text>
</xsl:template>

<xsl:template match="jvm:multianewarray">
  <xsl:text>    _op1.o = [XMLVMArray createMultiDimensionsWithType:</xsl:text>
  <xsl:value-of select="vm:typeID(@base-type)"/>
  <xsl:text> dimensions:&amp;_stack[_sp - </xsl:text>
  <xsl:value-of select="@dimensions"/>
  <xsl:text>] count:</xsl:text>
  <xsl:value-of select="@dimensions"/>
  <xsl:text>];
    _sp -= </xsl:text>
  <xsl:value-of select="@dimensions"/>
  <xsl:text>;
    _stack[_sp++].o = _op1.o;
 </xsl:text>
</xsl:template>

<xsl:template match="jvm:arraylength">
  <xsl:text>    _op1.i = [_stack[--_sp].o count];
    _stack[_sp++].i = _op1.i;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:aaload">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _op2.o = _stack[--_sp].o;
    _stack[_sp++].o = [_op2.o objectAtIndex: _op1.i];
</xsl:text>
</xsl:template>


<xsl:template match="jvm:caload|jvm:iaload|jvm:baload">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _op2.o = _stack[--_sp].o;
    _stack[_sp++].i = ((XMLVMArray*) _op2.o)->array.i[_op1.i];
</xsl:text>
</xsl:template>


<xsl:template match="jvm:daload">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _op2.o = _stack[--_sp].o;
    _stack[_sp++].d = ((XMLVMArray*) _op2.o)->array.d[_op1.i];
</xsl:text>
</xsl:template>


<xsl:template match="jvm:faload">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _op2.o = _stack[--_sp].o;
    _stack[_sp++].f = ((XMLVMArray*) _op2.o)->array.f[_op1.i];
</xsl:text>
</xsl:template>


<xsl:template match="jvm:aastore">
  <xsl:text>    _op1.o = _stack[--_sp].o;
    _op2.i = _stack[--_sp].i;
    _op3.o = _stack[--_sp].o;
    [_op3.o replaceObjectAtIndex: _op2.i withObject: _op1.o];
</xsl:text>
</xsl:template>


<xsl:template match="jvm:castore|jvm:iastore|jvm:bastore">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _op2.i = _stack[--_sp].i;
    _op3.o = _stack[--_sp].o;
    ((XMLVMArray*) _op3.o)->array.i[_op2.i] = _op1.i;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:dastore">
  <xsl:text>    _op1.d = _stack[--_sp].d;
    _op2.i = _stack[--_sp].i;
    _op3.o = _stack[--_sp].o;
    ((XMLVMArray*) _op3.o)->array.d[_op2.i] = _op1.d;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:fastore">
  <xsl:text>    _op1.f = _stack[--_sp].f;
    _op2.i = _stack[--_sp].i;
    _op3.o = _stack[--_sp].o;
    ((XMLVMArray*) _op3.o)->array.f[_op2.i] = _op1.f;
</xsl:text>
</xsl:template>


<xsl:template match="jvm:checkcast">
  <!-- TODO should do a runtime type check -->
</xsl:template>

<xsl:template match="jvm:instanceof">
  <xsl:text>    _op1.o = _stack[--_sp].o;
    _stack[_sp++].i = _op1.o != [NSNull null] &amp;&amp; 
        ([_op1.o isKindOfClass: objc_getClass("</xsl:text><xsl:value-of select="vm:fixname(@type)"/><xsl:text>")] ||
         [_op1.o conformsToProtocol: objc_getProtocol("</xsl:text><xsl:value-of select="vm:fixname(@type)"/><xsl:text>")]);
</xsl:text>
</xsl:template>

<xsl:template name="emitType">
  <xsl:param name="type"/>
  <xsl:choose>
    <xsl:when test="$type = 'void'">
      <xsl:text>void</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'char'">
      <xsl:text>int</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'int'">
      <xsl:text>int</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'long'">
      <xsl:text>long</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'float'">
      <xsl:text>float</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'double'">
      <xsl:text>double</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'boolean'">
      <xsl:text>int</xsl:text>
    </xsl:when>
    <xsl:when test="ends-with($type, '[]')">
      <xsl:text>XMLVMArray*</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="vm:fixname($type)"/>
      <xsl:text>*</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<xsl:template name="emitMethodName">
  <xsl:param name="name"/>
  <xsl:param name="class-type"/>
  <xsl:choose>
    <xsl:when test="$name = '&lt;init&gt;'">
      <xsl:text>__init_</xsl:text>
      <xsl:value-of select="vm:fixname($class-type)"/>
    </xsl:when>
    <xsl:when test="$name = '&lt;clinit&gt;'">
      <xsl:text>__clinit_</xsl:text>
      <xsl:value-of select="vm:fixname($class-type)"/>
    </xsl:when>
    <xsl:when test="$name = 'finalize'">
      <xsl:text>finalize_</xsl:text>
      <xsl:value-of select="vm:fixname($class-type)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$name"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<xsl:template name="emitMethodSignature">
  <xsl:value-of select="if (@isStatic = 'true') then '+' else '-'"/>
  <xsl:text> (</xsl:text>
  <xsl:call-template name="emitType">
    <xsl:with-param name="type" select="vm:signature/vm:return/@type"/>
  </xsl:call-template>
  <xsl:text>) </xsl:text>
  <xsl:call-template name="emitMethodName">
    <xsl:with-param name="name" select="@name"/>
    <xsl:with-param name="class-type" select="concat(../@package, '.', ../@name)"/>
  </xsl:call-template>
  <xsl:if test="@name != '&lt;clinit&gt;'">
    <xsl:call-template name="appendSignature"/>
    <xsl:for-each select="vm:signature/vm:parameter">
      <xsl:text> :(</xsl:text>
      <xsl:call-template name="emitType">
        <xsl:with-param name="type" select="@type"/>
      </xsl:call-template>
      <xsl:text>)n</xsl:text>
      <xsl:value-of select="position()"/>
    </xsl:for-each>
  </xsl:if>
</xsl:template>


<xsl:template name="appendSignature">
  <xsl:text>__</xsl:text>
  <xsl:choose>
    <xsl:when test="count(vm:signature/vm:parameter) != 0">
      <xsl:for-each select="vm:signature/vm:parameter">
        <xsl:text>_</xsl:text>
        <xsl:value-of select="replace(vm:fixname(@type), '\[\]', '_ARRAYTYPE')"/>
      </xsl:for-each>
    </xsl:when>
  </xsl:choose>
</xsl:template>

    
<!--
   initLocals
   ==========
   This function is called from the template for <code>. Its task is
   to initialize the local variables. This basically means that the
   actual parameters have to be copied to _locals[i]. If the method
   is not static, 'this' will be copied to _locals[0].
-->

<xsl:template name="initLocals">
    <xsl:for-each select="jvm:var">
		<xsl:choose>    
      		<xsl:when test="@name = 'this'">
      			<xsl:text>    _locals[</xsl:text>
    			<xsl:value-of select="@id" />
    			<xsl:text>].o = self;
</xsl:text>
     		</xsl:when>
     		<xsl:otherwise>
     			<xsl:if test="(position()-count(../jvm:var[@name='this'])) &lt;= count(../../vm:signature/vm:parameter)" >
     			  <xsl:text>    _locals[</xsl:text>
     	  		  <xsl:value-of select="@id" />
     	  		  <xsl:text>]</xsl:text>
     	  		  <xsl:call-template name="emitTypedAccess">
     	  		    <xsl:with-param name="type" select="@type"/>
     	  		  </xsl:call-template>
     	  		  <xsl:text> = n</xsl:text>
     	  		  <xsl:value-of select="(position()-count(../jvm:var[@name='this']))" />
     	  		  <xsl:text>;
</xsl:text>
     			</xsl:if>
     		</xsl:otherwise>
     	</xsl:choose>
    </xsl:for-each>
</xsl:template>


<xsl:template name="emitTypedAccess">
  <xsl:param name="type"/>
  
  <xsl:text>.</xsl:text>
  <xsl:choose>
    <xsl:when test="$type = 'char'">
      <xsl:text>i</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'int' or $type = 'boolean'">
      <xsl:text>i</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'float'">
      <xsl:text>f</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'double'">
      <xsl:text>d</xsl:text>
    </xsl:when>
    <xsl:when test="$type = 'long'">
      <xsl:text>l</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>o</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!--  javac will sometimes generate two methods that only differ in their return type.
      This can happen e.g. with type erasures. Function vm:isDuplicateMethod will determine
      if the given method is a duplicate that is not needed when generating Objective-C (in fact,
      Objective-C does not permit two methods that only differ in their return type).
      A method is a duplicate if it is (1) synthetic, (2) a method with the same name exists
      in the class, and (3) signatures only differ in their return types.  -->
<xsl:function name="vm:isDuplicateMethod" as="xs:boolean">
  <xsl:param name="method" as="node()"/>

  <xsl:choose>
    <xsl:when test="not($method/@isSynthetic = 'true')">
      <xsl:value-of select="false()"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="name" select="$method/@name"/>
      <xsl:variable name="methodsWithSameName" select="$method/../vm:method[@name = $name]"/>
      <xsl:variable name="duplicateMethods">
        <xsl:for-each select="$methodsWithSameName">
          <xsl:if test="deep-equal($method/vm:signature/vm:parameter, ./vm:signature/vm:parameter)">
            <xsl:copy-of select="."/>
          </xsl:if>
        </xsl:for-each>
      </xsl:variable>
      <xsl:value-of select="count($duplicateMethods/vm:method) gt 1"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>


<xsl:function name="vm:isObjectRef" as="xs:boolean">
  <xsl:param name="type" as="xs:string"/>
  
  <xsl:value-of select="not($type='byte' or $type='short' or $type='int' or $type='float' or $type='long' or $type='double' or
                            $type='char' or $type='boolean' or $type='void')"/>
</xsl:function>


<xsl:function name="vm:typeID" as="xs:integer">
  <xsl:param name="type" as="xs:string"/>
  
  <xsl:choose>
    <xsl:when test="$type='boolean'">
      <xsl:value-of select="1"/>
    </xsl:when>
    <xsl:when test="$type='char'">
      <xsl:value-of select="2"/>
    </xsl:when>
    <xsl:when test="$type='byte'">
      <xsl:value-of select="3"/>
    </xsl:when>
    <xsl:when test="$type='short'">
      <xsl:value-of select="4"/>
    </xsl:when>
    <xsl:when test="$type='int'">
      <xsl:value-of select="5"/>
    </xsl:when>
    <xsl:when test="$type='float'">
      <xsl:value-of select="6"/>
    </xsl:when>
    <xsl:when test="$type='double'">
      <xsl:value-of select="7"/>
    </xsl:when>
    <xsl:when test="$type='long'">
      <xsl:value-of select="8"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="0"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>


<xsl:function name="vm:useAutoReleasePool" as="xs:boolean">
  <xsl:param name="type" as="node()"/>
  
  <xsl:variable name="flag" select="$type/ancestor::vm:class/vm:annotations/vm:annotation[@type='org.xmlvm.iphone.XMLVMNoAutoReleasePool']"/>
  <xsl:value-of select="not($flag = '')"/>
</xsl:function>



<xsl:function name="vm:fixname">
  <xsl:param  name="a"/>
  <xsl:value-of  select="replace(replace($a,'\$', '_'),'\.','_')"/>
</xsl:function>
  
  
<xsl:template match="vm:annotations">
  <!-- Ignore annotations -->
</xsl:template>

<!-- Kev Adds -->
<xsl:template match="jvm:ishl">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    _stack[_sp++].i = _op1.i &lt;&lt; _op2.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:lshl">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.l = _stack[--_sp].l;
    _stack[_sp++].l = _op1.l &lt;&lt; _op2.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:ishr">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    _stack[_sp++].i = _op1.i &gt;&gt; _op2.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:lushr">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.l = _stack[--_sp].l;
    _stack[_sp++].l = ((unsigned long) _op1.l) &gt;&gt; _op2.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:iushr">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    _stack[_sp++].i = ((unsigned int) _op1.i) &gt;&gt; _op2.i;</xsl:text>
</xsl:template>

<xsl:template match="jvm:dup2">
  <xsl:text>    _op1 = _stack[_sp - 2];
    _op2 = _stack[_sp - 1];

    _stack[_sp++] = _op1;    
    _stack[_sp++] = _op2;
</xsl:text>
</xsl:template>

<xsl:template match="jvm:if_icmpgt">
  <xsl:text>    _op2.i = _stack[--_sp].i;
    _op1.i = _stack[--_sp].i;
    if (_op1.i &gt; _op2.i) goto label</xsl:text>
  <xsl:value-of select="@label"/>
  <xsl:text>;
</xsl:text>
</xsl:template>

<xsl:template match="jvm:dcmpl">
  <xsl:text>    _op2.f = (float) _stack[--_sp].d;
    _op1.f = (float) _stack[--_sp].d;
    _op3.i = -1;
    if (_op1.f &gt; _op2.f)
      _op3.i = 1;
    else if (_op1.f == _op2.f)
      _op3.i = 0;
    else if (_op1.f &lt; _op2.f)
      _op3.i = -1;
    _stack[_sp++].i = _op3.i;
</xsl:text>
</xsl:template>

<xsl:template match="jvm:lcmp">
    <xsl:text>    _op2.l = _stack[--_sp].l;
    _op1.l = _stack[--_sp].l;
    _op3.i = 1;
    if (_op1.l &gt; _op2.l)
      _op3.i = 1;
    else if (_op1.l == _op2.l)
      _op3.i = 0;
    else if (_op1.l &lt; _op2.l)
      _op3.i = -1;
    _stack[_sp++].i = _op3.i;
</xsl:text>
</xsl:template>

<xsl:template match="jvm:monitorenter">
  <xsl:text>    _op1.o = _stack[--_sp].o;
  	@synchronized(_op1.o) {
</xsl:text>
</xsl:template>

<xsl:template match="jvm:monitorexit">
  <xsl:text>    }
</xsl:text>
</xsl:template>

<xsl:template match="jvm:l2i">
  <xsl:text>    _op1.l = _stack[--_sp].l;
  _stack[_sp++].i = (int) _op1.l;</xsl:text>
</xsl:template>

<xsl:template match="jvm:i2c">
  <xsl:text>    _op1.i = _stack[--_sp].i;
  _stack[_sp++].i = _op1.i &amp; 0xff;</xsl:text>
</xsl:template>

<xsl:template match="jvm:ladd">
  <xsl:text>    _op2.l = _stack[--_sp].l;
    _op1.l = _stack[--_sp].l;
    _stack[_sp++].l = _op1.l + _op2.l;</xsl:text>
</xsl:template>

<xsl:template match="jvm:lmul">
  <xsl:text>    _op2.l = _stack[--_sp].l;
    _op1.l = _stack[--_sp].l;
    _stack[_sp++].l = _op1.l * _op2.l;</xsl:text>
</xsl:template>

<xsl:template match="jvm:ldiv">
  <xsl:text>    _op2.l = _stack[--_sp].l;
    _op1.l = _stack[--_sp].l;
    _stack[_sp++].l = _op1.l / _op2.l;</xsl:text>
</xsl:template>

<xsl:template match="jvm:lrem">
  <xsl:text>    _op2.l = _stack[--_sp].l;
    _op1.l = _stack[--_sp].l;
    _stack[_sp++].l = _op1.l % _op2.l;</xsl:text>
</xsl:template>

<xsl:template match="jvm:lor">
  <xsl:text>    _op2.l = _stack[--_sp].l;
    _op1.l = _stack[--_sp].l;
    _stack[_sp++].l = _op1.l | _op2.l;</xsl:text>
</xsl:template>

<xsl:template match="jvm:dup_x2">
  <xsl:text>    _op1.i = _stack[--_sp].i;
    _op2.i = _stack[--_sp].i;
    _op3.i = _stack[--_sp].i;
    _stack[_sp++].i = _op1.l;
    _stack[_sp++].i = _op3.l;
    _stack[_sp++].i = _op2.l;
    _stack[_sp++].i = _op1.l;</xsl:text>
</xsl:template>

<xsl:template match="jvm:lstore">
  <xsl:text>    _op1.l = _stack[--_sp].l;
    _locals[</xsl:text>
  <xsl:value-of select="@index"/>
  <xsl:text>].l = _op1.l;
</xsl:text>
</xsl:template>

<!-- natte adds -->

<xsl:template match="jvm:dsub">
    <xsl:text>    _op2.d = _stack[--_sp].d;
    _op1.d = _stack[--_sp].d;
    _stack[_sp++].d = _op1.d - _op2.d;
</xsl:text>
</xsl:template>

<xsl:template match="jvm:lsub">
    <xsl:text>    _op2.l = _stack[--_sp].l;
    _op1.l = _stack[--_sp].l;
    _stack[_sp++].l = _op1.l - _op2.l;
</xsl:text>
</xsl:template>

<!-- ********************************************************************************** -->
<!-- ********************************************************************************** -->
<!-- ********************************************************************************** -->
<!-- ********************************************************************************** -->
<!-- ********************************************************************************** -->
<!-- ********************************************************************************** -->
<!-- DEX Templates -->
<!-- http://www.netmite.com/android/mydroid/dalvik/docs/dalvik-bytecode.html -->
<!-- http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html -->


<xsl:template match="dex:code">
<xsl:text>{
    id        _res;
</xsl:text>
  <xsl:variable name="limit" select="@register-size" as="xs:integer"/>
  <xsl:for-each select="(0 to $limit - 1)">
    <xsl:text>    XMLVMElem _r</xsl:text>
    <xsl:value-of select="position() - 1"/>
    <xsl:text>;
</xsl:text>
  </xsl:for-each>
  <xsl:if test="vm:useAutoReleasePool(.)">
    <xsl:text>    NSAutoreleasePool* _pool = [[NSAutoreleasePool alloc] init];
</xsl:text>
  </xsl:if>
  <xsl:call-template name="initDexLocals"/>
  <xsl:apply-templates/>
  <xsl:text>}


</xsl:text>
</xsl:template>


<xsl:template match="dex:var">
  <!-- Do nothing -->
</xsl:template>


<xsl:template match="dex:invoke-static|dex:invoke-static-range">
  <xsl:variable name="returnTypedAccess">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="dex:parameters/dex:return/@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    </xsl:text>
  <xsl:if test="dex:parameters/dex:return/@type != 'void'">
    <xsl:choose>
      <xsl:when test="dex:move-result">
        <xsl:text>_r</xsl:text>
        <xsl:value-of select="dex:move-result/@vx"/>
        <xsl:value-of select="$returnTypedAccess"/>
        <xsl:text> = </xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="vm:isObjectRef(dex:parameters/dex:return/@type)">
          <xsl:text>_res = </xsl:text>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
  <xsl:text>[</xsl:text>
  <xsl:value-of select="vm:fixname(@class-type)"/>
  <xsl:text> </xsl:text>
  <xsl:value-of select="@method"/>
  <xsl:call-template name="appendDexSignature"/>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:text>:_r</xsl:text>
    <xsl:value-of select="@register"/>
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
  </xsl:for-each>
  <xsl:text>];
</xsl:text>
  <xsl:if test="vm:isObjectRef(dex:parameters/dex:return/@type)">
    <xsl:choose>
      <xsl:when test="dex:move-result">
        <xsl:text>    [_r</xsl:text>
        <xsl:value-of select="dex:move-result/@vx"/>
        <xsl:value-of select="$returnTypedAccess"/>
        <xsl:text> autorelease];</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>    [_res release];</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>
</xsl:text>
  </xsl:if>
</xsl:template>


<xsl:template match="dex:invoke-direct|dex:invoke-direct-range|dex:invoke-virtual|dex:invoke-virtual-range|dex:invoke-interface|dex:invoke-interface-range">
  <xsl:variable name="returnTypedAccess">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="dex:parameters/dex:return/@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    </xsl:text>
  <xsl:if test="dex:parameters/dex:return/@type != 'void'">
    <xsl:choose>
      <xsl:when test="dex:move-result">
        <xsl:text>_r</xsl:text>
        <xsl:value-of select="dex:move-result/@vx"/>
        <xsl:value-of select="$returnTypedAccess"/>
        <xsl:text> = </xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="vm:isObjectRef(dex:parameters/dex:return/@type)">
          <xsl:text>_res = </xsl:text>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
  <xsl:text>[((</xsl:text>
  
  <xsl:variable name="baseClass">
    <xsl:value-of select="ancestor::dex:class/@extends"/>
  </xsl:variable>
  <xsl:choose>
 	<xsl:when test="name() = 'dex:invoke-virtual' or compare(@class-type,$baseClass) != 0">
		  <xsl:call-template name="emitType">
		    <xsl:with-param name="type" select="@class-type"/>
  			</xsl:call-template>
  		<xsl:text>) _r</xsl:text>
  		<xsl:value-of select="@register"/>
  		<xsl:text>.o) </xsl:text>
  	</xsl:when>
    <xsl:otherwise>
	  <xsl:text>super)) </xsl:text>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:call-template name="emitMethodName">
    <xsl:with-param name="name" select="@method"/>
    <xsl:with-param name="class-type" select="@class-type"/>
  </xsl:call-template>
  <xsl:call-template name="appendDexSignature"/>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:text>:_r</xsl:text>
    <xsl:value-of select="@register"/>
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
  </xsl:for-each>
  <xsl:text>];
</xsl:text>
  <xsl:if test="vm:isObjectRef(dex:parameters/dex:return/@type)">
    <xsl:choose>
      <xsl:when test="dex:move-result">
        <xsl:text>    [_r</xsl:text>
        <xsl:value-of select="dex:move-result/@vx"/>
        <xsl:value-of select="$returnTypedAccess"/>
        <xsl:text> autorelease];</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>    [_res release];</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>
</xsl:text>
  </xsl:if>
</xsl:template>


<xsl:template match="dex:invoke-super|dex:invoke-super-range">
  <xsl:variable name="returnTypedAccess">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="dex:parameters/dex:return/@type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    </xsl:text>
  <xsl:if test="dex:parameters/dex:return/@type != 'void'">
    <xsl:choose>
      <xsl:when test="dex:move-result">
        <xsl:text>_r</xsl:text>
        <xsl:value-of select="dex:move-result/@vx"/>
        <xsl:value-of select="$returnTypedAccess"/>
        <xsl:text> = </xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="vm:isObjectRef(dex:parameters/dex:return/@type)">
          <xsl:text>_res = </xsl:text>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
  <!-- TODO what to do with @register? -->
  <xsl:text>[super </xsl:text>

  <xsl:call-template name="emitMethodName">
    <xsl:with-param name="name" select="@method"/>
    <xsl:with-param name="class-type" select="@class-type"/>
  </xsl:call-template>
  <xsl:call-template name="appendDexSignature"/>
  <xsl:for-each select="dex:parameters/dex:parameter">
    <xsl:text>:_r</xsl:text>
    <xsl:value-of select="@register"/>
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@type"/>
    </xsl:call-template>
  </xsl:for-each>
  <xsl:text>];
</xsl:text>
  <xsl:if test="vm:isObjectRef(dex:parameters/dex:return/@type)">
    <xsl:choose>
      <xsl:when test="dex:move-result">
        <xsl:text>    [_r</xsl:text>
        <xsl:value-of select="dex:move-result/@vx"/>
        <xsl:value-of select="$returnTypedAccess"/>
        <xsl:text> autorelease];</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>    [_res release];</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>
</xsl:text>
  </xsl:if>
</xsl:template>


<xsl:template match="dex:monitor-enter">
  <!-- TODO we can't map this to @synchronized {} because DEX may
       generate multiple monitor-exit for one monitor-enter -->
</xsl:template>


<xsl:template match="dex:monitor-exit">
  <!-- TODO we can't map this to @synchronized {} because DEX may
       generate multiple monitor-exit for one monitor-enter -->
</xsl:template>


<xsl:template match="dex:try-catch">
  <xsl:apply-templates/>
</xsl:template>


<xsl:template match="dex:try">
  <xsl:apply-templates/>
</xsl:template>


<xsl:template match="dex:catch">
  <!-- TODO -->
</xsl:template>


<xsl:template match="dex:catches">
  <!-- TODO -->
</xsl:template>


<xsl:template match="dex:throw">
  <!-- TODO -->
</xsl:template>


<xsl:template match="dex:move-exception">
  <!-- TODO -->
</xsl:template>


<xsl:template match="dex:add-int|dex:add-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i + _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:sub-int|dex:sub-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i - _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:mul-int|dex:mul-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i * _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:div-int|dex:div-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i / _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:rem-int|dex:rem-int-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i % _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>

  
<xsl:template match="dex:add-float|dex:add-float-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f + _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:sub-float|dex:sub-float-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f - _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:div-float|dex:div-float-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f / _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-float|dex:mul-float-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f * _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:add-double|dex:add-double-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d + _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:sub-double|dex:sub-double-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d - _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:div-double|dex:div-double-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d / _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:mul-double|dex:mul-double-2addr">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d * _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:return-void">
  <xsl:if test="vm:useAutoReleasePool(.)">
    <xsl:text>    [_pool release];
</xsl:text>
  </xsl:if>
  <xsl:text>    return;
</xsl:text>
</xsl:template>


<xsl:template match="dex:return|dex:return-object">
  <xsl:variable name="return-type" select="ancestor::vm:method/vm:signature/vm:return/@type"/>
  <xsl:if test="vm:isObjectRef($return-type)">
    <xsl:text>    [_r</xsl:text>
    <xsl:value-of select="@vx"/>
    <xsl:text>.o retain];
</xsl:text>
  </xsl:if>
  <xsl:if test="vm:useAutoReleasePool(.)">
    <xsl:text>    [_pool release];
</xsl:text>
  </xsl:if>
  <xsl:text>    return _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="$return-type"/>
  </xsl:call-template>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:new-instance">
    <xsl:text>    _r</xsl:text>
    <xsl:value-of select="@vx"/>
    <xsl:text>.o = [[[</xsl:text>
    <xsl:value-of select="vm:fixname(@value)"/>
    <xsl:text> alloc] init] autorelease];
</xsl:text>
</xsl:template>


<xsl:template match="dex:iget|dex:iget-wide|dex:iget-object|dex:iget-boolean">
  <xsl:variable name="m">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@member-type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:value-of select="$m"/>
  <xsl:text> = [((</xsl:text>
  <xsl:call-template name="emitType">
    <xsl:with-param name="type" select="@class-type"/>
  </xsl:call-template>
  <xsl:text>) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.o) </xsl:text>
  <xsl:text> _GET_</xsl:text>
  <xsl:value-of select="vm:fixname(@member-name)"/>
  <xsl:text>];
</xsl:text>
</xsl:template>


<xsl:template match="dex:iput|dex:iput-wide|dex:iput-object|dex:iput-boolean">
  <xsl:variable name="m">
    <xsl:call-template name="emitTypedAccess">
      <xsl:with-param name="type" select="@member-type"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:text>    [((</xsl:text>
  <xsl:call-template name="emitType">
    <xsl:with-param name="type" select="@class-type"/>
  </xsl:call-template>
  <xsl:text>) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.o) _PUT_</xsl:text>
  <xsl:value-of select="vm:fixname(@member-name)"/>
  <xsl:text>: _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:value-of select="$m"/>
  <xsl:text>];
</xsl:text>
</xsl:template>



<xsl:template match="dex:sget|dex:sget-object">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@member-type"/>
  </xsl:call-template>
  <xsl:text> = [</xsl:text>
  <xsl:value-of select="vm:fixname(@class-type)"/>
  <xsl:text> _GET_</xsl:text>
  <xsl:value-of select="vm:fixname(@member-name)"/>
  <xsl:text>];
</xsl:text>
</xsl:template>


<xsl:template match="dex:sput|dex:sput-object">
  <xsl:text>    [</xsl:text>
  <xsl:value-of select="vm:fixname(@class-type)"/>
  <xsl:text> _PUT_</xsl:text>
  <xsl:value-of select="vm:fixname(@member-name)"/>
  <xsl:text>: _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@member-type"/>
  </xsl:call-template>
  <xsl:text>];
</xsl:text>
</xsl:template>



<xsl:template match="dex:const-4[@kind='known-null']"> 
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = [NSNull null];
</xsl:text>
</xsl:template>


<xsl:template match="dex:const|dex:const-4|dex:const-16|dex:const-wide|dex:const-wide-16|dex:const-high16|dex:const-wide-high16"> 
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@type"/>
  </xsl:call-template>
  <xsl:text> = </xsl:text>
  <xsl:value-of select="@value"/>
  <xs:text>;
</xs:text>
</xsl:template>


<xsl:template match="dex:const-string"> 
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = @"</xsl:text>
  <xsl:value-of select="@value"/>
  <xs:text>";
</xs:text>
</xsl:template>


<xsl:template match="dex:const-class"> 
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = [[</xsl:text>
  <xsl:value-of select="vm:fixname(@value)"/>
  <xs:text> getClass__] autorelease];
</xs:text>
</xsl:template>


<xsl:template match="dex:float-to-int">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (int) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:float-to-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = (double) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = (float) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-long">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.l = (long) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:int-to-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.d = (double) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:double-to-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = (float) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:double-to-int">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = (int) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d;
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpl-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpg-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.f ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpl-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:cmpg-double">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d &gt; _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 1 : (_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.d == _r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.d ? 0 : -1);
</xsl:text>
</xsl:template>


<xsl:template match="dex:neg-float">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.f = -_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.f;
</xsl:text>
</xsl:template>


<xsl:template match="dex:add-int-lit8">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i + </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:div-int-lit8">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i / </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:rem-int-lit8">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i % </xsl:text>
  <xsl:value-of select="@value"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:label">
  <xsl:text>    label</xsl:text>
  <xsl:value-of select="@id"/>
  <xsl:text>:;
</xsl:text>
</xsl:template>


<xsl:template match="dex:goto">
  <xsl:text>    goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-eqz">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:choose>
    <xsl:when test="vm:isObjectRef(@vx-type)">
      <xsl:text>.o == [NSNull null]</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="emitTypedAccess">
        <xsl:with-param name="type" select="@vx-type"/>
      </xsl:call-template>
      <xsl:text> == 0</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-nez">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:choose>
    <xsl:when test="vm:isObjectRef(@vx-type)">
      <xsl:text>.o != [NSNull null]</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="emitTypedAccess">
        <xsl:with-param name="type" select="@vx-type"/>
      </xsl:call-template>
      <xsl:text> != 0</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-gez">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt;= 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ltz">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt; 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-lez">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt;= 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-gtz">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt; 0) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ge">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &gt;= _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-le">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt;= _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-lt">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> &lt; _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-eq">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> == _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:if-ne">
  <xsl:text>    if (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vx-type"/>
  </xsl:call-template>
  <xsl:text> != _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:call-template name="emitTypedAccess">
    <xsl:with-param name="type" select="@vy-type"/>
  </xsl:call-template>
  <xsl:text>) goto label</xsl:text>
  <xsl:value-of select="@target"/>
  <xsl:text>;
</xsl:text>
</xsl:template>


<xsl:template match="dex:sparse-switch|dex:packed-switch">
  <xsl:text>    switch (_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i) {
</xsl:text>
  <xsl:for-each select="dex:case">
    <xsl:text>    case </xsl:text>
    <xsl:value-of select="@key"/>
    <xsl:text>: goto label</xsl:text>
    <xsl:value-of select="@label"/>
    <xsl:text>;
</xsl:text>
  </xsl:for-each>
  <xsl:text>    }
</xsl:text>
</xsl:template>

<xsl:template match="dex:new-array">
  <xsl:variable name="base-type" select="replace(@value, '\[\]', '')"/>
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = [XMLVMArray createSingleDimensionWithType:</xsl:text>
  <xsl:value-of select="vm:typeID($base-type)"/>
  <xsl:text> andSize:_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.i];
</xsl:text>
</xsl:template>


<xsl:template match="dex:array-length">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = [_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.o count];
</xsl:text>
</xsl:template>


<xsl:template match="dex:aget|dex:aget-char">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i = ((XMLVMArray*) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.o)->array.i[_r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i];
</xsl:text>
</xsl:template>


<xsl:template match="dex:aget-object">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = [_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.o objectAtIndex:_r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i];
</xsl:text>
</xsl:template>


<xsl:template match="dex:aput|dex:aput-char">
  <xsl:text>    ((XMLVMArray*) _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.o)->array.i[_r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i] = _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.i;
</xsl:text>
</xsl:template>


<xsl:template match="dex:aput-object">
  <xsl:text>    [_r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.o replaceObjectAtIndex:_r</xsl:text>
  <xsl:value-of select="@vz"/>
  <xsl:text>.i withObject:_r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o];
</xsl:text>
</xsl:template>


<xsl:template match="dex:check-cast">
  <!-- TODO should do a runtime type check -->
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text>.o = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>.o;
</xsl:text>
</xsl:template>



<xsl:template match="dex:move|dex:move-object">
  <xsl:text>    _r</xsl:text>
  <xsl:value-of select="@vx"/>
  <xsl:text> = _r</xsl:text>
  <xsl:value-of select="@vy"/>
  <xsl:text>;
</xsl:text>
</xsl:template>



<xsl:template name="initDexLocals">
    <xsl:for-each select="dex:var">
		<xsl:choose>    
      		<xsl:when test="@name = 'this'">
      			<xsl:text>    _r</xsl:text>
    			<xsl:value-of select="@register" />
    			<xsl:text>.o = self;
</xsl:text>
     		</xsl:when>
     		<xsl:otherwise>
     			<xsl:if test="(position()-count(../dex:var[@name='this'])) &lt;= count(../../vm:signature/vm:parameter)" >
     			  <xsl:text>    _r</xsl:text>
     	  		  <xsl:value-of select="@register" />
     	  		  <xsl:call-template name="emitTypedAccess">
     	  		    <xsl:with-param name="type" select="@type"/>
     	  		  </xsl:call-template>
     	  		  <xsl:text> = n</xsl:text>
     	  		  <xsl:value-of select="(position()-count(../dex:var[@name='this']))" />
     	  		  <xsl:text>;
</xsl:text>
     			</xsl:if>
     		</xsl:otherwise>
     	</xsl:choose>
    </xsl:for-each>
</xsl:template>


<xsl:template name="appendDexSignature">
  <xsl:text>__</xsl:text>
  <xsl:choose>
    <xsl:when test="count(dex:parameters/dex:parameter) != 0">
      <xsl:for-each select="dex:parameters/dex:parameter">
        <xsl:text>_</xsl:text>
        <xsl:value-of select="replace(vm:fixname(@type), '\[\]', '_ARRAYTYPE')"/>
      </xsl:for-each>
    </xsl:when>
  </xsl:choose>
</xsl:template>



<!--
   Default template. If the XMLVM file should contain an instruction
   that is not handled by this stylesheet, this default template
   will make sure we notice it by writing a special error function
   to the output stream.
-->
<xsl:template match="*">
  <xsl:text>      ERROR("</xsl:text>
  <xsl:value-of select="name()"/>
    <xsl:text>");
</xsl:text>
  <xsl:message select="."/>
</xsl:template>


</xsl:stylesheet>
